// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: msg/msg.proto

package msg

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on MsgDataToMQ with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MsgDataToMQ) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgDataToMQ with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MsgDataToMQMultiError, or
// nil if none found.
func (m *MsgDataToMQ) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgDataToMQ) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if all {
		switch v := interface{}(m.GetMsgData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MsgDataToMQValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MsgDataToMQValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMsgData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MsgDataToMQValidationError{
				field:  "MsgData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MsgDataToMQMultiError(errors)
	}

	return nil
}

// MsgDataToMQMultiError is an error wrapping multiple validation errors
// returned by MsgDataToMQ.ValidateAll() if the designated constraints aren't met.
type MsgDataToMQMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgDataToMQMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgDataToMQMultiError) AllErrors() []error { return m }

// MsgDataToMQValidationError is the validation error returned by
// MsgDataToMQ.Validate if the designated constraints aren't met.
type MsgDataToMQValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgDataToMQValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgDataToMQValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgDataToMQValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgDataToMQValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgDataToMQValidationError) ErrorName() string { return "MsgDataToMQValidationError" }

// Error satisfies the builtin error interface
func (e MsgDataToMQValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgDataToMQ.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgDataToMQValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgDataToMQValidationError{}

// Validate checks the field values on MsgDataToDB with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MsgDataToDB) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgDataToDB with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MsgDataToDBMultiError, or
// nil if none found.
func (m *MsgDataToDB) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgDataToDB) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMsgData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MsgDataToDBValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MsgDataToDBValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMsgData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MsgDataToDBValidationError{
				field:  "MsgData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MsgDataToDBMultiError(errors)
	}

	return nil
}

// MsgDataToDBMultiError is an error wrapping multiple validation errors
// returned by MsgDataToDB.ValidateAll() if the designated constraints aren't met.
type MsgDataToDBMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgDataToDBMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgDataToDBMultiError) AllErrors() []error { return m }

// MsgDataToDBValidationError is the validation error returned by
// MsgDataToDB.Validate if the designated constraints aren't met.
type MsgDataToDBValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgDataToDBValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgDataToDBValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgDataToDBValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgDataToDBValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgDataToDBValidationError) ErrorName() string { return "MsgDataToDBValidationError" }

// Error satisfies the builtin error interface
func (e MsgDataToDBValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgDataToDB.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgDataToDBValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgDataToDBValidationError{}

// Validate checks the field values on PushMsgDataToMQ with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PushMsgDataToMQ) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PushMsgDataToMQ with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PushMsgDataToMQMultiError, or nil if none found.
func (m *PushMsgDataToMQ) ValidateAll() error {
	return m.validate(true)
}

func (m *PushMsgDataToMQ) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMsgData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PushMsgDataToMQValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PushMsgDataToMQValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMsgData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PushMsgDataToMQValidationError{
				field:  "MsgData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConversationID

	if len(errors) > 0 {
		return PushMsgDataToMQMultiError(errors)
	}

	return nil
}

// PushMsgDataToMQMultiError is an error wrapping multiple validation errors
// returned by PushMsgDataToMQ.ValidateAll() if the designated constraints
// aren't met.
type PushMsgDataToMQMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PushMsgDataToMQMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PushMsgDataToMQMultiError) AllErrors() []error { return m }

// PushMsgDataToMQValidationError is the validation error returned by
// PushMsgDataToMQ.Validate if the designated constraints aren't met.
type PushMsgDataToMQValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PushMsgDataToMQValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PushMsgDataToMQValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PushMsgDataToMQValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PushMsgDataToMQValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PushMsgDataToMQValidationError) ErrorName() string { return "PushMsgDataToMQValidationError" }

// Error satisfies the builtin error interface
func (e PushMsgDataToMQValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPushMsgDataToMQ.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PushMsgDataToMQValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PushMsgDataToMQValidationError{}

// Validate checks the field values on MsgDataToMongoByMQ with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MsgDataToMongoByMQ) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgDataToMongoByMQ with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MsgDataToMongoByMQMultiError, or nil if none found.
func (m *MsgDataToMongoByMQ) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgDataToMongoByMQ) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LastSeq

	// no validation rules for ConversationID

	for idx, item := range m.GetMsgData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MsgDataToMongoByMQValidationError{
						field:  fmt.Sprintf("MsgData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MsgDataToMongoByMQValidationError{
						field:  fmt.Sprintf("MsgData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MsgDataToMongoByMQValidationError{
					field:  fmt.Sprintf("MsgData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MsgDataToMongoByMQMultiError(errors)
	}

	return nil
}

// MsgDataToMongoByMQMultiError is an error wrapping multiple validation errors
// returned by MsgDataToMongoByMQ.ValidateAll() if the designated constraints
// aren't met.
type MsgDataToMongoByMQMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgDataToMongoByMQMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgDataToMongoByMQMultiError) AllErrors() []error { return m }

// MsgDataToMongoByMQValidationError is the validation error returned by
// MsgDataToMongoByMQ.Validate if the designated constraints aren't met.
type MsgDataToMongoByMQValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgDataToMongoByMQValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgDataToMongoByMQValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgDataToMongoByMQValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgDataToMongoByMQValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgDataToMongoByMQValidationError) ErrorName() string {
	return "MsgDataToMongoByMQValidationError"
}

// Error satisfies the builtin error interface
func (e MsgDataToMongoByMQValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgDataToMongoByMQ.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgDataToMongoByMQValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgDataToMongoByMQValidationError{}

// Validate checks the field values on GetMaxAndMinSeqReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMaxAndMinSeqReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaxAndMinSeqReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMaxAndMinSeqReqMultiError, or nil if none found.
func (m *GetMaxAndMinSeqReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaxAndMinSeqReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if len(errors) > 0 {
		return GetMaxAndMinSeqReqMultiError(errors)
	}

	return nil
}

// GetMaxAndMinSeqReqMultiError is an error wrapping multiple validation errors
// returned by GetMaxAndMinSeqReq.ValidateAll() if the designated constraints
// aren't met.
type GetMaxAndMinSeqReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaxAndMinSeqReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaxAndMinSeqReqMultiError) AllErrors() []error { return m }

// GetMaxAndMinSeqReqValidationError is the validation error returned by
// GetMaxAndMinSeqReq.Validate if the designated constraints aren't met.
type GetMaxAndMinSeqReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaxAndMinSeqReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaxAndMinSeqReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaxAndMinSeqReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaxAndMinSeqReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaxAndMinSeqReqValidationError) ErrorName() string {
	return "GetMaxAndMinSeqReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetMaxAndMinSeqReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaxAndMinSeqReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaxAndMinSeqReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaxAndMinSeqReqValidationError{}

// Validate checks the field values on GetMaxAndMinSeqResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMaxAndMinSeqResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaxAndMinSeqResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMaxAndMinSeqRespMultiError, or nil if none found.
func (m *GetMaxAndMinSeqResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaxAndMinSeqResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxSeq

	// no validation rules for MinSeq

	if len(errors) > 0 {
		return GetMaxAndMinSeqRespMultiError(errors)
	}

	return nil
}

// GetMaxAndMinSeqRespMultiError is an error wrapping multiple validation
// errors returned by GetMaxAndMinSeqResp.ValidateAll() if the designated
// constraints aren't met.
type GetMaxAndMinSeqRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaxAndMinSeqRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaxAndMinSeqRespMultiError) AllErrors() []error { return m }

// GetMaxAndMinSeqRespValidationError is the validation error returned by
// GetMaxAndMinSeqResp.Validate if the designated constraints aren't met.
type GetMaxAndMinSeqRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaxAndMinSeqRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaxAndMinSeqRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaxAndMinSeqRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaxAndMinSeqRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaxAndMinSeqRespValidationError) ErrorName() string {
	return "GetMaxAndMinSeqRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetMaxAndMinSeqRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaxAndMinSeqResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaxAndMinSeqRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaxAndMinSeqRespValidationError{}

// Validate checks the field values on SendMsgReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendMsgReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendMsgReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendMsgReqMultiError, or
// nil if none found.
func (m *SendMsgReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SendMsgReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMsgData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendMsgReqValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendMsgReqValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMsgData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendMsgReqValidationError{
				field:  "MsgData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SendMsgReqMultiError(errors)
	}

	return nil
}

// SendMsgReqMultiError is an error wrapping multiple validation errors
// returned by SendMsgReq.ValidateAll() if the designated constraints aren't met.
type SendMsgReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendMsgReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendMsgReqMultiError) AllErrors() []error { return m }

// SendMsgReqValidationError is the validation error returned by
// SendMsgReq.Validate if the designated constraints aren't met.
type SendMsgReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendMsgReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendMsgReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendMsgReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendMsgReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendMsgReqValidationError) ErrorName() string { return "SendMsgReqValidationError" }

// Error satisfies the builtin error interface
func (e SendMsgReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendMsgReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendMsgReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendMsgReqValidationError{}

// Validate checks the field values on SendMsgResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendMsgResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendMsgResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendMsgRespMultiError, or
// nil if none found.
func (m *SendMsgResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SendMsgResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServerMsgID

	// no validation rules for ClientMsgID

	// no validation rules for SendTime

	if len(errors) > 0 {
		return SendMsgRespMultiError(errors)
	}

	return nil
}

// SendMsgRespMultiError is an error wrapping multiple validation errors
// returned by SendMsgResp.ValidateAll() if the designated constraints aren't met.
type SendMsgRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendMsgRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendMsgRespMultiError) AllErrors() []error { return m }

// SendMsgRespValidationError is the validation error returned by
// SendMsgResp.Validate if the designated constraints aren't met.
type SendMsgRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendMsgRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendMsgRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendMsgRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendMsgRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendMsgRespValidationError) ErrorName() string { return "SendMsgRespValidationError" }

// Error satisfies the builtin error interface
func (e SendMsgRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendMsgResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendMsgRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendMsgRespValidationError{}

// Validate checks the field values on SetSendMsgStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetSendMsgStatusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetSendMsgStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetSendMsgStatusReqMultiError, or nil if none found.
func (m *SetSendMsgStatusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetSendMsgStatusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if len(errors) > 0 {
		return SetSendMsgStatusReqMultiError(errors)
	}

	return nil
}

// SetSendMsgStatusReqMultiError is an error wrapping multiple validation
// errors returned by SetSendMsgStatusReq.ValidateAll() if the designated
// constraints aren't met.
type SetSendMsgStatusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetSendMsgStatusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetSendMsgStatusReqMultiError) AllErrors() []error { return m }

// SetSendMsgStatusReqValidationError is the validation error returned by
// SetSendMsgStatusReq.Validate if the designated constraints aren't met.
type SetSendMsgStatusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetSendMsgStatusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetSendMsgStatusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetSendMsgStatusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetSendMsgStatusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetSendMsgStatusReqValidationError) ErrorName() string {
	return "SetSendMsgStatusReqValidationError"
}

// Error satisfies the builtin error interface
func (e SetSendMsgStatusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetSendMsgStatusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetSendMsgStatusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetSendMsgStatusReqValidationError{}

// Validate checks the field values on SetSendMsgStatusResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetSendMsgStatusResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetSendMsgStatusResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetSendMsgStatusRespMultiError, or nil if none found.
func (m *SetSendMsgStatusResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SetSendMsgStatusResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetSendMsgStatusRespMultiError(errors)
	}

	return nil
}

// SetSendMsgStatusRespMultiError is an error wrapping multiple validation
// errors returned by SetSendMsgStatusResp.ValidateAll() if the designated
// constraints aren't met.
type SetSendMsgStatusRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetSendMsgStatusRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetSendMsgStatusRespMultiError) AllErrors() []error { return m }

// SetSendMsgStatusRespValidationError is the validation error returned by
// SetSendMsgStatusResp.Validate if the designated constraints aren't met.
type SetSendMsgStatusRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetSendMsgStatusRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetSendMsgStatusRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetSendMsgStatusRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetSendMsgStatusRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetSendMsgStatusRespValidationError) ErrorName() string {
	return "SetSendMsgStatusRespValidationError"
}

// Error satisfies the builtin error interface
func (e SetSendMsgStatusRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetSendMsgStatusResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetSendMsgStatusRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetSendMsgStatusRespValidationError{}

// Validate checks the field values on GetSendMsgStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSendMsgStatusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSendMsgStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSendMsgStatusReqMultiError, or nil if none found.
func (m *GetSendMsgStatusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSendMsgStatusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetSendMsgStatusReqMultiError(errors)
	}

	return nil
}

// GetSendMsgStatusReqMultiError is an error wrapping multiple validation
// errors returned by GetSendMsgStatusReq.ValidateAll() if the designated
// constraints aren't met.
type GetSendMsgStatusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSendMsgStatusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSendMsgStatusReqMultiError) AllErrors() []error { return m }

// GetSendMsgStatusReqValidationError is the validation error returned by
// GetSendMsgStatusReq.Validate if the designated constraints aren't met.
type GetSendMsgStatusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSendMsgStatusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSendMsgStatusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSendMsgStatusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSendMsgStatusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSendMsgStatusReqValidationError) ErrorName() string {
	return "GetSendMsgStatusReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetSendMsgStatusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSendMsgStatusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSendMsgStatusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSendMsgStatusReqValidationError{}

// Validate checks the field values on GetSendMsgStatusResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSendMsgStatusResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSendMsgStatusResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSendMsgStatusRespMultiError, or nil if none found.
func (m *GetSendMsgStatusResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSendMsgStatusResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if len(errors) > 0 {
		return GetSendMsgStatusRespMultiError(errors)
	}

	return nil
}

// GetSendMsgStatusRespMultiError is an error wrapping multiple validation
// errors returned by GetSendMsgStatusResp.ValidateAll() if the designated
// constraints aren't met.
type GetSendMsgStatusRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSendMsgStatusRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSendMsgStatusRespMultiError) AllErrors() []error { return m }

// GetSendMsgStatusRespValidationError is the validation error returned by
// GetSendMsgStatusResp.Validate if the designated constraints aren't met.
type GetSendMsgStatusRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSendMsgStatusRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSendMsgStatusRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSendMsgStatusRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSendMsgStatusRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSendMsgStatusRespValidationError) ErrorName() string {
	return "GetSendMsgStatusRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetSendMsgStatusRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSendMsgStatusResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSendMsgStatusRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSendMsgStatusRespValidationError{}

// Validate checks the field values on MsgDataToModifyByMQ with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MsgDataToModifyByMQ) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgDataToModifyByMQ with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MsgDataToModifyByMQMultiError, or nil if none found.
func (m *MsgDataToModifyByMQ) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgDataToModifyByMQ) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMessages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MsgDataToModifyByMQValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MsgDataToModifyByMQValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MsgDataToModifyByMQValidationError{
					field:  fmt.Sprintf("Messages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ConversationID

	if len(errors) > 0 {
		return MsgDataToModifyByMQMultiError(errors)
	}

	return nil
}

// MsgDataToModifyByMQMultiError is an error wrapping multiple validation
// errors returned by MsgDataToModifyByMQ.ValidateAll() if the designated
// constraints aren't met.
type MsgDataToModifyByMQMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgDataToModifyByMQMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgDataToModifyByMQMultiError) AllErrors() []error { return m }

// MsgDataToModifyByMQValidationError is the validation error returned by
// MsgDataToModifyByMQ.Validate if the designated constraints aren't met.
type MsgDataToModifyByMQValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgDataToModifyByMQValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgDataToModifyByMQValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgDataToModifyByMQValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgDataToModifyByMQValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgDataToModifyByMQValidationError) ErrorName() string {
	return "MsgDataToModifyByMQValidationError"
}

// Error satisfies the builtin error interface
func (e MsgDataToModifyByMQValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgDataToModifyByMQ.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgDataToModifyByMQValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgDataToModifyByMQValidationError{}

// Validate checks the field values on DelMsgsReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DelMsgsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DelMsgsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DelMsgsReqMultiError, or
// nil if none found.
func (m *DelMsgsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DelMsgsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DelMsgsReqMultiError(errors)
	}

	return nil
}

// DelMsgsReqMultiError is an error wrapping multiple validation errors
// returned by DelMsgsReq.ValidateAll() if the designated constraints aren't met.
type DelMsgsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DelMsgsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DelMsgsReqMultiError) AllErrors() []error { return m }

// DelMsgsReqValidationError is the validation error returned by
// DelMsgsReq.Validate if the designated constraints aren't met.
type DelMsgsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DelMsgsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DelMsgsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DelMsgsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DelMsgsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DelMsgsReqValidationError) ErrorName() string { return "DelMsgsReqValidationError" }

// Error satisfies the builtin error interface
func (e DelMsgsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDelMsgsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DelMsgsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DelMsgsReqValidationError{}

// Validate checks the field values on DelMsgsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DelMsgsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DelMsgsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DelMsgsRespMultiError, or
// nil if none found.
func (m *DelMsgsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DelMsgsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DelMsgsRespMultiError(errors)
	}

	return nil
}

// DelMsgsRespMultiError is an error wrapping multiple validation errors
// returned by DelMsgsResp.ValidateAll() if the designated constraints aren't met.
type DelMsgsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DelMsgsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DelMsgsRespMultiError) AllErrors() []error { return m }

// DelMsgsRespValidationError is the validation error returned by
// DelMsgsResp.Validate if the designated constraints aren't met.
type DelMsgsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DelMsgsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DelMsgsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DelMsgsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DelMsgsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DelMsgsRespValidationError) ErrorName() string { return "DelMsgsRespValidationError" }

// Error satisfies the builtin error interface
func (e DelMsgsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDelMsgsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DelMsgsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DelMsgsRespValidationError{}

// Validate checks the field values on RevokeMsgReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RevokeMsgReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeMsgReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RevokeMsgReqMultiError, or
// nil if none found.
func (m *RevokeMsgReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeMsgReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	// no validation rules for Seq

	// no validation rules for UserID

	if len(errors) > 0 {
		return RevokeMsgReqMultiError(errors)
	}

	return nil
}

// RevokeMsgReqMultiError is an error wrapping multiple validation errors
// returned by RevokeMsgReq.ValidateAll() if the designated constraints aren't met.
type RevokeMsgReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeMsgReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeMsgReqMultiError) AllErrors() []error { return m }

// RevokeMsgReqValidationError is the validation error returned by
// RevokeMsgReq.Validate if the designated constraints aren't met.
type RevokeMsgReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeMsgReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeMsgReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeMsgReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeMsgReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeMsgReqValidationError) ErrorName() string { return "RevokeMsgReqValidationError" }

// Error satisfies the builtin error interface
func (e RevokeMsgReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeMsgReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeMsgReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeMsgReqValidationError{}

// Validate checks the field values on RevokeMsgResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RevokeMsgResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeMsgResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RevokeMsgRespMultiError, or
// nil if none found.
func (m *RevokeMsgResp) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeMsgResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RevokeMsgRespMultiError(errors)
	}

	return nil
}

// RevokeMsgRespMultiError is an error wrapping multiple validation errors
// returned by RevokeMsgResp.ValidateAll() if the designated constraints
// aren't met.
type RevokeMsgRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeMsgRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeMsgRespMultiError) AllErrors() []error { return m }

// RevokeMsgRespValidationError is the validation error returned by
// RevokeMsgResp.Validate if the designated constraints aren't met.
type RevokeMsgRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeMsgRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeMsgRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeMsgRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeMsgRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeMsgRespValidationError) ErrorName() string { return "RevokeMsgRespValidationError" }

// Error satisfies the builtin error interface
func (e RevokeMsgRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeMsgResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeMsgRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeMsgRespValidationError{}

// Validate checks the field values on MarkMsgsAsReadReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MarkMsgsAsReadReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkMsgsAsReadReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarkMsgsAsReadReqMultiError, or nil if none found.
func (m *MarkMsgsAsReadReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkMsgsAsReadReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	// no validation rules for UserID

	if len(errors) > 0 {
		return MarkMsgsAsReadReqMultiError(errors)
	}

	return nil
}

// MarkMsgsAsReadReqMultiError is an error wrapping multiple validation errors
// returned by MarkMsgsAsReadReq.ValidateAll() if the designated constraints
// aren't met.
type MarkMsgsAsReadReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkMsgsAsReadReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkMsgsAsReadReqMultiError) AllErrors() []error { return m }

// MarkMsgsAsReadReqValidationError is the validation error returned by
// MarkMsgsAsReadReq.Validate if the designated constraints aren't met.
type MarkMsgsAsReadReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkMsgsAsReadReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkMsgsAsReadReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkMsgsAsReadReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkMsgsAsReadReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkMsgsAsReadReqValidationError) ErrorName() string {
	return "MarkMsgsAsReadReqValidationError"
}

// Error satisfies the builtin error interface
func (e MarkMsgsAsReadReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkMsgsAsReadReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkMsgsAsReadReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkMsgsAsReadReqValidationError{}

// Validate checks the field values on MarkMsgsAsReadResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MarkMsgsAsReadResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkMsgsAsReadResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarkMsgsAsReadRespMultiError, or nil if none found.
func (m *MarkMsgsAsReadResp) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkMsgsAsReadResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MarkMsgsAsReadRespMultiError(errors)
	}

	return nil
}

// MarkMsgsAsReadRespMultiError is an error wrapping multiple validation errors
// returned by MarkMsgsAsReadResp.ValidateAll() if the designated constraints
// aren't met.
type MarkMsgsAsReadRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkMsgsAsReadRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkMsgsAsReadRespMultiError) AllErrors() []error { return m }

// MarkMsgsAsReadRespValidationError is the validation error returned by
// MarkMsgsAsReadResp.Validate if the designated constraints aren't met.
type MarkMsgsAsReadRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkMsgsAsReadRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkMsgsAsReadRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkMsgsAsReadRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkMsgsAsReadRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkMsgsAsReadRespValidationError) ErrorName() string {
	return "MarkMsgsAsReadRespValidationError"
}

// Error satisfies the builtin error interface
func (e MarkMsgsAsReadRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkMsgsAsReadResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkMsgsAsReadRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkMsgsAsReadRespValidationError{}

// Validate checks the field values on MarkConversationAsReadReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MarkConversationAsReadReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkConversationAsReadReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarkConversationAsReadReqMultiError, or nil if none found.
func (m *MarkConversationAsReadReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkConversationAsReadReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	// no validation rules for UserID

	// no validation rules for HasReadSeq

	if len(errors) > 0 {
		return MarkConversationAsReadReqMultiError(errors)
	}

	return nil
}

// MarkConversationAsReadReqMultiError is an error wrapping multiple validation
// errors returned by MarkConversationAsReadReq.ValidateAll() if the
// designated constraints aren't met.
type MarkConversationAsReadReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkConversationAsReadReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkConversationAsReadReqMultiError) AllErrors() []error { return m }

// MarkConversationAsReadReqValidationError is the validation error returned by
// MarkConversationAsReadReq.Validate if the designated constraints aren't met.
type MarkConversationAsReadReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkConversationAsReadReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkConversationAsReadReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkConversationAsReadReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkConversationAsReadReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkConversationAsReadReqValidationError) ErrorName() string {
	return "MarkConversationAsReadReqValidationError"
}

// Error satisfies the builtin error interface
func (e MarkConversationAsReadReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkConversationAsReadReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkConversationAsReadReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkConversationAsReadReqValidationError{}

// Validate checks the field values on MarkConversationAsReadResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MarkConversationAsReadResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkConversationAsReadResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarkConversationAsReadRespMultiError, or nil if none found.
func (m *MarkConversationAsReadResp) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkConversationAsReadResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MarkConversationAsReadRespMultiError(errors)
	}

	return nil
}

// MarkConversationAsReadRespMultiError is an error wrapping multiple
// validation errors returned by MarkConversationAsReadResp.ValidateAll() if
// the designated constraints aren't met.
type MarkConversationAsReadRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkConversationAsReadRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkConversationAsReadRespMultiError) AllErrors() []error { return m }

// MarkConversationAsReadRespValidationError is the validation error returned
// by MarkConversationAsReadResp.Validate if the designated constraints aren't met.
type MarkConversationAsReadRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkConversationAsReadRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkConversationAsReadRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkConversationAsReadRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkConversationAsReadRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkConversationAsReadRespValidationError) ErrorName() string {
	return "MarkConversationAsReadRespValidationError"
}

// Error satisfies the builtin error interface
func (e MarkConversationAsReadRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkConversationAsReadResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkConversationAsReadRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkConversationAsReadRespValidationError{}

// Validate checks the field values on SetConversationHasReadSeqReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetConversationHasReadSeqReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetConversationHasReadSeqReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetConversationHasReadSeqReqMultiError, or nil if none found.
func (m *SetConversationHasReadSeqReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetConversationHasReadSeqReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	// no validation rules for UserID

	// no validation rules for HasReadSeq

	// no validation rules for NoNotification

	if len(errors) > 0 {
		return SetConversationHasReadSeqReqMultiError(errors)
	}

	return nil
}

// SetConversationHasReadSeqReqMultiError is an error wrapping multiple
// validation errors returned by SetConversationHasReadSeqReq.ValidateAll() if
// the designated constraints aren't met.
type SetConversationHasReadSeqReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetConversationHasReadSeqReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetConversationHasReadSeqReqMultiError) AllErrors() []error { return m }

// SetConversationHasReadSeqReqValidationError is the validation error returned
// by SetConversationHasReadSeqReq.Validate if the designated constraints
// aren't met.
type SetConversationHasReadSeqReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetConversationHasReadSeqReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetConversationHasReadSeqReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetConversationHasReadSeqReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetConversationHasReadSeqReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetConversationHasReadSeqReqValidationError) ErrorName() string {
	return "SetConversationHasReadSeqReqValidationError"
}

// Error satisfies the builtin error interface
func (e SetConversationHasReadSeqReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetConversationHasReadSeqReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetConversationHasReadSeqReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetConversationHasReadSeqReqValidationError{}

// Validate checks the field values on SetConversationHasReadSeqResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetConversationHasReadSeqResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetConversationHasReadSeqResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SetConversationHasReadSeqRespMultiError, or nil if none found.
func (m *SetConversationHasReadSeqResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SetConversationHasReadSeqResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetConversationHasReadSeqRespMultiError(errors)
	}

	return nil
}

// SetConversationHasReadSeqRespMultiError is an error wrapping multiple
// validation errors returned by SetConversationHasReadSeqResp.ValidateAll()
// if the designated constraints aren't met.
type SetConversationHasReadSeqRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetConversationHasReadSeqRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetConversationHasReadSeqRespMultiError) AllErrors() []error { return m }

// SetConversationHasReadSeqRespValidationError is the validation error
// returned by SetConversationHasReadSeqResp.Validate if the designated
// constraints aren't met.
type SetConversationHasReadSeqRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetConversationHasReadSeqRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetConversationHasReadSeqRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetConversationHasReadSeqRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetConversationHasReadSeqRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetConversationHasReadSeqRespValidationError) ErrorName() string {
	return "SetConversationHasReadSeqRespValidationError"
}

// Error satisfies the builtin error interface
func (e SetConversationHasReadSeqRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetConversationHasReadSeqResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetConversationHasReadSeqRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetConversationHasReadSeqRespValidationError{}

// Validate checks the field values on DeleteSyncOpt with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteSyncOpt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSyncOpt with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteSyncOptMultiError, or
// nil if none found.
func (m *DeleteSyncOpt) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSyncOpt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsSyncSelf

	// no validation rules for IsSyncOther

	if len(errors) > 0 {
		return DeleteSyncOptMultiError(errors)
	}

	return nil
}

// DeleteSyncOptMultiError is an error wrapping multiple validation errors
// returned by DeleteSyncOpt.ValidateAll() if the designated constraints
// aren't met.
type DeleteSyncOptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSyncOptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSyncOptMultiError) AllErrors() []error { return m }

// DeleteSyncOptValidationError is the validation error returned by
// DeleteSyncOpt.Validate if the designated constraints aren't met.
type DeleteSyncOptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSyncOptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSyncOptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSyncOptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSyncOptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSyncOptValidationError) ErrorName() string { return "DeleteSyncOptValidationError" }

// Error satisfies the builtin error interface
func (e DeleteSyncOptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSyncOpt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSyncOptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSyncOptValidationError{}

// Validate checks the field values on ClearConversationsMsgReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClearConversationsMsgReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClearConversationsMsgReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClearConversationsMsgReqMultiError, or nil if none found.
func (m *ClearConversationsMsgReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ClearConversationsMsgReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if all {
		switch v := interface{}(m.GetDeleteSyncOpt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClearConversationsMsgReqValidationError{
					field:  "DeleteSyncOpt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClearConversationsMsgReqValidationError{
					field:  "DeleteSyncOpt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteSyncOpt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClearConversationsMsgReqValidationError{
				field:  "DeleteSyncOpt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClearConversationsMsgReqMultiError(errors)
	}

	return nil
}

// ClearConversationsMsgReqMultiError is an error wrapping multiple validation
// errors returned by ClearConversationsMsgReq.ValidateAll() if the designated
// constraints aren't met.
type ClearConversationsMsgReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClearConversationsMsgReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClearConversationsMsgReqMultiError) AllErrors() []error { return m }

// ClearConversationsMsgReqValidationError is the validation error returned by
// ClearConversationsMsgReq.Validate if the designated constraints aren't met.
type ClearConversationsMsgReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClearConversationsMsgReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClearConversationsMsgReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClearConversationsMsgReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClearConversationsMsgReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClearConversationsMsgReqValidationError) ErrorName() string {
	return "ClearConversationsMsgReqValidationError"
}

// Error satisfies the builtin error interface
func (e ClearConversationsMsgReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClearConversationsMsgReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClearConversationsMsgReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClearConversationsMsgReqValidationError{}

// Validate checks the field values on ClearConversationsMsgResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClearConversationsMsgResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClearConversationsMsgResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClearConversationsMsgRespMultiError, or nil if none found.
func (m *ClearConversationsMsgResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ClearConversationsMsgResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ClearConversationsMsgRespMultiError(errors)
	}

	return nil
}

// ClearConversationsMsgRespMultiError is an error wrapping multiple validation
// errors returned by ClearConversationsMsgResp.ValidateAll() if the
// designated constraints aren't met.
type ClearConversationsMsgRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClearConversationsMsgRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClearConversationsMsgRespMultiError) AllErrors() []error { return m }

// ClearConversationsMsgRespValidationError is the validation error returned by
// ClearConversationsMsgResp.Validate if the designated constraints aren't met.
type ClearConversationsMsgRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClearConversationsMsgRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClearConversationsMsgRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClearConversationsMsgRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClearConversationsMsgRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClearConversationsMsgRespValidationError) ErrorName() string {
	return "ClearConversationsMsgRespValidationError"
}

// Error satisfies the builtin error interface
func (e ClearConversationsMsgRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClearConversationsMsgResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClearConversationsMsgRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClearConversationsMsgRespValidationError{}

// Validate checks the field values on UserClearAllMsgReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserClearAllMsgReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserClearAllMsgReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserClearAllMsgReqMultiError, or nil if none found.
func (m *UserClearAllMsgReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserClearAllMsgReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if all {
		switch v := interface{}(m.GetDeleteSyncOpt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserClearAllMsgReqValidationError{
					field:  "DeleteSyncOpt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserClearAllMsgReqValidationError{
					field:  "DeleteSyncOpt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteSyncOpt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserClearAllMsgReqValidationError{
				field:  "DeleteSyncOpt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserClearAllMsgReqMultiError(errors)
	}

	return nil
}

// UserClearAllMsgReqMultiError is an error wrapping multiple validation errors
// returned by UserClearAllMsgReq.ValidateAll() if the designated constraints
// aren't met.
type UserClearAllMsgReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserClearAllMsgReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserClearAllMsgReqMultiError) AllErrors() []error { return m }

// UserClearAllMsgReqValidationError is the validation error returned by
// UserClearAllMsgReq.Validate if the designated constraints aren't met.
type UserClearAllMsgReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserClearAllMsgReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserClearAllMsgReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserClearAllMsgReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserClearAllMsgReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserClearAllMsgReqValidationError) ErrorName() string {
	return "UserClearAllMsgReqValidationError"
}

// Error satisfies the builtin error interface
func (e UserClearAllMsgReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserClearAllMsgReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserClearAllMsgReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserClearAllMsgReqValidationError{}

// Validate checks the field values on UserClearAllMsgResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserClearAllMsgResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserClearAllMsgResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserClearAllMsgRespMultiError, or nil if none found.
func (m *UserClearAllMsgResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserClearAllMsgResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserClearAllMsgRespMultiError(errors)
	}

	return nil
}

// UserClearAllMsgRespMultiError is an error wrapping multiple validation
// errors returned by UserClearAllMsgResp.ValidateAll() if the designated
// constraints aren't met.
type UserClearAllMsgRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserClearAllMsgRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserClearAllMsgRespMultiError) AllErrors() []error { return m }

// UserClearAllMsgRespValidationError is the validation error returned by
// UserClearAllMsgResp.Validate if the designated constraints aren't met.
type UserClearAllMsgRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserClearAllMsgRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserClearAllMsgRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserClearAllMsgRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserClearAllMsgRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserClearAllMsgRespValidationError) ErrorName() string {
	return "UserClearAllMsgRespValidationError"
}

// Error satisfies the builtin error interface
func (e UserClearAllMsgRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserClearAllMsgResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserClearAllMsgRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserClearAllMsgRespValidationError{}

// Validate checks the field values on DeleteMsgsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteMsgsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMsgsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteMsgsReqMultiError, or
// nil if none found.
func (m *DeleteMsgsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMsgsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	// no validation rules for UserID

	if all {
		switch v := interface{}(m.GetDeleteSyncOpt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteMsgsReqValidationError{
					field:  "DeleteSyncOpt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteMsgsReqValidationError{
					field:  "DeleteSyncOpt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteSyncOpt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteMsgsReqValidationError{
				field:  "DeleteSyncOpt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteMsgsReqMultiError(errors)
	}

	return nil
}

// DeleteMsgsReqMultiError is an error wrapping multiple validation errors
// returned by DeleteMsgsReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteMsgsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMsgsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMsgsReqMultiError) AllErrors() []error { return m }

// DeleteMsgsReqValidationError is the validation error returned by
// DeleteMsgsReq.Validate if the designated constraints aren't met.
type DeleteMsgsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMsgsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMsgsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMsgsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMsgsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMsgsReqValidationError) ErrorName() string { return "DeleteMsgsReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteMsgsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMsgsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMsgsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMsgsReqValidationError{}

// Validate checks the field values on DeleteMsgsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteMsgsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMsgsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteMsgsRespMultiError,
// or nil if none found.
func (m *DeleteMsgsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMsgsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteMsgsRespMultiError(errors)
	}

	return nil
}

// DeleteMsgsRespMultiError is an error wrapping multiple validation errors
// returned by DeleteMsgsResp.ValidateAll() if the designated constraints
// aren't met.
type DeleteMsgsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMsgsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMsgsRespMultiError) AllErrors() []error { return m }

// DeleteMsgsRespValidationError is the validation error returned by
// DeleteMsgsResp.Validate if the designated constraints aren't met.
type DeleteMsgsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMsgsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMsgsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMsgsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMsgsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMsgsRespValidationError) ErrorName() string { return "DeleteMsgsRespValidationError" }

// Error satisfies the builtin error interface
func (e DeleteMsgsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMsgsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMsgsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMsgsRespValidationError{}

// Validate checks the field values on DeleteMsgPhysicalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMsgPhysicalReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMsgPhysicalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMsgPhysicalReqMultiError, or nil if none found.
func (m *DeleteMsgPhysicalReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMsgPhysicalReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return DeleteMsgPhysicalReqMultiError(errors)
	}

	return nil
}

// DeleteMsgPhysicalReqMultiError is an error wrapping multiple validation
// errors returned by DeleteMsgPhysicalReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteMsgPhysicalReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMsgPhysicalReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMsgPhysicalReqMultiError) AllErrors() []error { return m }

// DeleteMsgPhysicalReqValidationError is the validation error returned by
// DeleteMsgPhysicalReq.Validate if the designated constraints aren't met.
type DeleteMsgPhysicalReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMsgPhysicalReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMsgPhysicalReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMsgPhysicalReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMsgPhysicalReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMsgPhysicalReqValidationError) ErrorName() string {
	return "DeleteMsgPhysicalReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMsgPhysicalReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMsgPhysicalReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMsgPhysicalReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMsgPhysicalReqValidationError{}

// Validate checks the field values on DeleteMsgPhysicalResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMsgPhysicalResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMsgPhysicalResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMsgPhysicalRespMultiError, or nil if none found.
func (m *DeleteMsgPhysicalResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMsgPhysicalResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteMsgPhysicalRespMultiError(errors)
	}

	return nil
}

// DeleteMsgPhysicalRespMultiError is an error wrapping multiple validation
// errors returned by DeleteMsgPhysicalResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteMsgPhysicalRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMsgPhysicalRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMsgPhysicalRespMultiError) AllErrors() []error { return m }

// DeleteMsgPhysicalRespValidationError is the validation error returned by
// DeleteMsgPhysicalResp.Validate if the designated constraints aren't met.
type DeleteMsgPhysicalRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMsgPhysicalRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMsgPhysicalRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMsgPhysicalRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMsgPhysicalRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMsgPhysicalRespValidationError) ErrorName() string {
	return "DeleteMsgPhysicalRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMsgPhysicalRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMsgPhysicalResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMsgPhysicalRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMsgPhysicalRespValidationError{}

// Validate checks the field values on DeleteMsgPhysicalBySeqReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMsgPhysicalBySeqReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMsgPhysicalBySeqReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMsgPhysicalBySeqReqMultiError, or nil if none found.
func (m *DeleteMsgPhysicalBySeqReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMsgPhysicalBySeqReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	if len(errors) > 0 {
		return DeleteMsgPhysicalBySeqReqMultiError(errors)
	}

	return nil
}

// DeleteMsgPhysicalBySeqReqMultiError is an error wrapping multiple validation
// errors returned by DeleteMsgPhysicalBySeqReq.ValidateAll() if the
// designated constraints aren't met.
type DeleteMsgPhysicalBySeqReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMsgPhysicalBySeqReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMsgPhysicalBySeqReqMultiError) AllErrors() []error { return m }

// DeleteMsgPhysicalBySeqReqValidationError is the validation error returned by
// DeleteMsgPhysicalBySeqReq.Validate if the designated constraints aren't met.
type DeleteMsgPhysicalBySeqReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMsgPhysicalBySeqReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMsgPhysicalBySeqReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMsgPhysicalBySeqReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMsgPhysicalBySeqReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMsgPhysicalBySeqReqValidationError) ErrorName() string {
	return "DeleteMsgPhysicalBySeqReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMsgPhysicalBySeqReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMsgPhysicalBySeqReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMsgPhysicalBySeqReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMsgPhysicalBySeqReqValidationError{}

// Validate checks the field values on DeleteMsgPhysicalBySeqResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMsgPhysicalBySeqResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMsgPhysicalBySeqResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMsgPhysicalBySeqRespMultiError, or nil if none found.
func (m *DeleteMsgPhysicalBySeqResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMsgPhysicalBySeqResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteMsgPhysicalBySeqRespMultiError(errors)
	}

	return nil
}

// DeleteMsgPhysicalBySeqRespMultiError is an error wrapping multiple
// validation errors returned by DeleteMsgPhysicalBySeqResp.ValidateAll() if
// the designated constraints aren't met.
type DeleteMsgPhysicalBySeqRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMsgPhysicalBySeqRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMsgPhysicalBySeqRespMultiError) AllErrors() []error { return m }

// DeleteMsgPhysicalBySeqRespValidationError is the validation error returned
// by DeleteMsgPhysicalBySeqResp.Validate if the designated constraints aren't met.
type DeleteMsgPhysicalBySeqRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMsgPhysicalBySeqRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMsgPhysicalBySeqRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMsgPhysicalBySeqRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMsgPhysicalBySeqRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMsgPhysicalBySeqRespValidationError) ErrorName() string {
	return "DeleteMsgPhysicalBySeqRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMsgPhysicalBySeqRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMsgPhysicalBySeqResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMsgPhysicalBySeqRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMsgPhysicalBySeqRespValidationError{}

// Validate checks the field values on GetMaxSeqsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMaxSeqsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaxSeqsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMaxSeqsReqMultiError, or
// nil if none found.
func (m *GetMaxSeqsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaxSeqsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetMaxSeqsReqMultiError(errors)
	}

	return nil
}

// GetMaxSeqsReqMultiError is an error wrapping multiple validation errors
// returned by GetMaxSeqsReq.ValidateAll() if the designated constraints
// aren't met.
type GetMaxSeqsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaxSeqsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaxSeqsReqMultiError) AllErrors() []error { return m }

// GetMaxSeqsReqValidationError is the validation error returned by
// GetMaxSeqsReq.Validate if the designated constraints aren't met.
type GetMaxSeqsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaxSeqsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaxSeqsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaxSeqsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaxSeqsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaxSeqsReqValidationError) ErrorName() string { return "GetMaxSeqsReqValidationError" }

// Error satisfies the builtin error interface
func (e GetMaxSeqsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaxSeqsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaxSeqsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaxSeqsReqValidationError{}

// Validate checks the field values on GetHasReadSeqsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetHasReadSeqsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHasReadSeqsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHasReadSeqsReqMultiError, or nil if none found.
func (m *GetHasReadSeqsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHasReadSeqsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if len(errors) > 0 {
		return GetHasReadSeqsReqMultiError(errors)
	}

	return nil
}

// GetHasReadSeqsReqMultiError is an error wrapping multiple validation errors
// returned by GetHasReadSeqsReq.ValidateAll() if the designated constraints
// aren't met.
type GetHasReadSeqsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHasReadSeqsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHasReadSeqsReqMultiError) AllErrors() []error { return m }

// GetHasReadSeqsReqValidationError is the validation error returned by
// GetHasReadSeqsReq.Validate if the designated constraints aren't met.
type GetHasReadSeqsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHasReadSeqsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHasReadSeqsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHasReadSeqsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHasReadSeqsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHasReadSeqsReqValidationError) ErrorName() string {
	return "GetHasReadSeqsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetHasReadSeqsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHasReadSeqsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHasReadSeqsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHasReadSeqsReqValidationError{}

// Validate checks the field values on SeqsInfoResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SeqsInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SeqsInfoResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SeqsInfoRespMultiError, or
// nil if none found.
func (m *SeqsInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SeqsInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxSeqs

	if len(errors) > 0 {
		return SeqsInfoRespMultiError(errors)
	}

	return nil
}

// SeqsInfoRespMultiError is an error wrapping multiple validation errors
// returned by SeqsInfoResp.ValidateAll() if the designated constraints aren't met.
type SeqsInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SeqsInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SeqsInfoRespMultiError) AllErrors() []error { return m }

// SeqsInfoRespValidationError is the validation error returned by
// SeqsInfoResp.Validate if the designated constraints aren't met.
type SeqsInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SeqsInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SeqsInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SeqsInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SeqsInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SeqsInfoRespValidationError) ErrorName() string { return "SeqsInfoRespValidationError" }

// Error satisfies the builtin error interface
func (e SeqsInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSeqsInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SeqsInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SeqsInfoRespValidationError{}

// Validate checks the field values on GetMsgByConversationIDsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMsgByConversationIDsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMsgByConversationIDsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMsgByConversationIDsReqMultiError, or nil if none found.
func (m *GetMsgByConversationIDsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMsgByConversationIDsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxSeqs

	if len(errors) > 0 {
		return GetMsgByConversationIDsReqMultiError(errors)
	}

	return nil
}

// GetMsgByConversationIDsReqMultiError is an error wrapping multiple
// validation errors returned by GetMsgByConversationIDsReq.ValidateAll() if
// the designated constraints aren't met.
type GetMsgByConversationIDsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMsgByConversationIDsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMsgByConversationIDsReqMultiError) AllErrors() []error { return m }

// GetMsgByConversationIDsReqValidationError is the validation error returned
// by GetMsgByConversationIDsReq.Validate if the designated constraints aren't met.
type GetMsgByConversationIDsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMsgByConversationIDsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMsgByConversationIDsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMsgByConversationIDsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMsgByConversationIDsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMsgByConversationIDsReqValidationError) ErrorName() string {
	return "GetMsgByConversationIDsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetMsgByConversationIDsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMsgByConversationIDsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMsgByConversationIDsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMsgByConversationIDsReqValidationError{}

// Validate checks the field values on GetMsgByConversationIDsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMsgByConversationIDsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMsgByConversationIDsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMsgByConversationIDsRespMultiError, or nil if none found.
func (m *GetMsgByConversationIDsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMsgByConversationIDsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetMsgDatas()))
		i := 0
		for key := range m.GetMsgDatas() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMsgDatas()[key]
			_ = val

			// no validation rules for MsgDatas[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetMsgByConversationIDsRespValidationError{
							field:  fmt.Sprintf("MsgDatas[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetMsgByConversationIDsRespValidationError{
							field:  fmt.Sprintf("MsgDatas[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetMsgByConversationIDsRespValidationError{
						field:  fmt.Sprintf("MsgDatas[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetMsgByConversationIDsRespMultiError(errors)
	}

	return nil
}

// GetMsgByConversationIDsRespMultiError is an error wrapping multiple
// validation errors returned by GetMsgByConversationIDsResp.ValidateAll() if
// the designated constraints aren't met.
type GetMsgByConversationIDsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMsgByConversationIDsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMsgByConversationIDsRespMultiError) AllErrors() []error { return m }

// GetMsgByConversationIDsRespValidationError is the validation error returned
// by GetMsgByConversationIDsResp.Validate if the designated constraints
// aren't met.
type GetMsgByConversationIDsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMsgByConversationIDsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMsgByConversationIDsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMsgByConversationIDsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMsgByConversationIDsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMsgByConversationIDsRespValidationError) ErrorName() string {
	return "GetMsgByConversationIDsRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetMsgByConversationIDsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMsgByConversationIDsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMsgByConversationIDsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMsgByConversationIDsRespValidationError{}

// Validate checks the field values on GetConversationMaxSeqReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConversationMaxSeqReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConversationMaxSeqReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConversationMaxSeqReqMultiError, or nil if none found.
func (m *GetConversationMaxSeqReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConversationMaxSeqReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	if len(errors) > 0 {
		return GetConversationMaxSeqReqMultiError(errors)
	}

	return nil
}

// GetConversationMaxSeqReqMultiError is an error wrapping multiple validation
// errors returned by GetConversationMaxSeqReq.ValidateAll() if the designated
// constraints aren't met.
type GetConversationMaxSeqReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConversationMaxSeqReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConversationMaxSeqReqMultiError) AllErrors() []error { return m }

// GetConversationMaxSeqReqValidationError is the validation error returned by
// GetConversationMaxSeqReq.Validate if the designated constraints aren't met.
type GetConversationMaxSeqReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConversationMaxSeqReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConversationMaxSeqReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConversationMaxSeqReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConversationMaxSeqReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConversationMaxSeqReqValidationError) ErrorName() string {
	return "GetConversationMaxSeqReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetConversationMaxSeqReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConversationMaxSeqReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConversationMaxSeqReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConversationMaxSeqReqValidationError{}

// Validate checks the field values on GetConversationMaxSeqResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConversationMaxSeqResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConversationMaxSeqResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConversationMaxSeqRespMultiError, or nil if none found.
func (m *GetConversationMaxSeqResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConversationMaxSeqResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxSeq

	if len(errors) > 0 {
		return GetConversationMaxSeqRespMultiError(errors)
	}

	return nil
}

// GetConversationMaxSeqRespMultiError is an error wrapping multiple validation
// errors returned by GetConversationMaxSeqResp.ValidateAll() if the
// designated constraints aren't met.
type GetConversationMaxSeqRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConversationMaxSeqRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConversationMaxSeqRespMultiError) AllErrors() []error { return m }

// GetConversationMaxSeqRespValidationError is the validation error returned by
// GetConversationMaxSeqResp.Validate if the designated constraints aren't met.
type GetConversationMaxSeqRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConversationMaxSeqRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConversationMaxSeqRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConversationMaxSeqRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConversationMaxSeqRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConversationMaxSeqRespValidationError) ErrorName() string {
	return "GetConversationMaxSeqRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetConversationMaxSeqRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConversationMaxSeqResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConversationMaxSeqRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConversationMaxSeqRespValidationError{}

// Validate checks the field values on GetConversationsHasReadAndMaxSeqReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetConversationsHasReadAndMaxSeqReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConversationsHasReadAndMaxSeqReq
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetConversationsHasReadAndMaxSeqReqMultiError, or nil if none found.
func (m *GetConversationsHasReadAndMaxSeqReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConversationsHasReadAndMaxSeqReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if len(errors) > 0 {
		return GetConversationsHasReadAndMaxSeqReqMultiError(errors)
	}

	return nil
}

// GetConversationsHasReadAndMaxSeqReqMultiError is an error wrapping multiple
// validation errors returned by
// GetConversationsHasReadAndMaxSeqReq.ValidateAll() if the designated
// constraints aren't met.
type GetConversationsHasReadAndMaxSeqReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConversationsHasReadAndMaxSeqReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConversationsHasReadAndMaxSeqReqMultiError) AllErrors() []error { return m }

// GetConversationsHasReadAndMaxSeqReqValidationError is the validation error
// returned by GetConversationsHasReadAndMaxSeqReq.Validate if the designated
// constraints aren't met.
type GetConversationsHasReadAndMaxSeqReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConversationsHasReadAndMaxSeqReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConversationsHasReadAndMaxSeqReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConversationsHasReadAndMaxSeqReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConversationsHasReadAndMaxSeqReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConversationsHasReadAndMaxSeqReqValidationError) ErrorName() string {
	return "GetConversationsHasReadAndMaxSeqReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetConversationsHasReadAndMaxSeqReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConversationsHasReadAndMaxSeqReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConversationsHasReadAndMaxSeqReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConversationsHasReadAndMaxSeqReqValidationError{}

// Validate checks the field values on Seqs with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Seqs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Seqs with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SeqsMultiError, or nil if none found.
func (m *Seqs) ValidateAll() error {
	return m.validate(true)
}

func (m *Seqs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxSeq

	// no validation rules for HasReadSeq

	// no validation rules for MaxSeqTime

	if len(errors) > 0 {
		return SeqsMultiError(errors)
	}

	return nil
}

// SeqsMultiError is an error wrapping multiple validation errors returned by
// Seqs.ValidateAll() if the designated constraints aren't met.
type SeqsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SeqsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SeqsMultiError) AllErrors() []error { return m }

// SeqsValidationError is the validation error returned by Seqs.Validate if the
// designated constraints aren't met.
type SeqsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SeqsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SeqsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SeqsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SeqsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SeqsValidationError) ErrorName() string { return "SeqsValidationError" }

// Error satisfies the builtin error interface
func (e SeqsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSeqs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SeqsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SeqsValidationError{}

// Validate checks the field values on GetConversationsHasReadAndMaxSeqResp
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetConversationsHasReadAndMaxSeqResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConversationsHasReadAndMaxSeqResp
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetConversationsHasReadAndMaxSeqRespMultiError, or nil if none found.
func (m *GetConversationsHasReadAndMaxSeqResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConversationsHasReadAndMaxSeqResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetSeqs()))
		i := 0
		for key := range m.GetSeqs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSeqs()[key]
			_ = val

			// no validation rules for Seqs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetConversationsHasReadAndMaxSeqRespValidationError{
							field:  fmt.Sprintf("Seqs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetConversationsHasReadAndMaxSeqRespValidationError{
							field:  fmt.Sprintf("Seqs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetConversationsHasReadAndMaxSeqRespValidationError{
						field:  fmt.Sprintf("Seqs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetConversationsHasReadAndMaxSeqRespMultiError(errors)
	}

	return nil
}

// GetConversationsHasReadAndMaxSeqRespMultiError is an error wrapping multiple
// validation errors returned by
// GetConversationsHasReadAndMaxSeqResp.ValidateAll() if the designated
// constraints aren't met.
type GetConversationsHasReadAndMaxSeqRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConversationsHasReadAndMaxSeqRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConversationsHasReadAndMaxSeqRespMultiError) AllErrors() []error { return m }

// GetConversationsHasReadAndMaxSeqRespValidationError is the validation error
// returned by GetConversationsHasReadAndMaxSeqResp.Validate if the designated
// constraints aren't met.
type GetConversationsHasReadAndMaxSeqRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConversationsHasReadAndMaxSeqRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConversationsHasReadAndMaxSeqRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConversationsHasReadAndMaxSeqRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConversationsHasReadAndMaxSeqRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConversationsHasReadAndMaxSeqRespValidationError) ErrorName() string {
	return "GetConversationsHasReadAndMaxSeqRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetConversationsHasReadAndMaxSeqRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConversationsHasReadAndMaxSeqResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConversationsHasReadAndMaxSeqRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConversationsHasReadAndMaxSeqRespValidationError{}

// Validate checks the field values on GetActiveUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetActiveUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetActiveUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetActiveUserReqMultiError, or nil if none found.
func (m *GetActiveUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetActiveUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for Ase

	// no validation rules for Group

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetActiveUserReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetActiveUserReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetActiveUserReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetActiveUserReqMultiError(errors)
	}

	return nil
}

// GetActiveUserReqMultiError is an error wrapping multiple validation errors
// returned by GetActiveUserReq.ValidateAll() if the designated constraints
// aren't met.
type GetActiveUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetActiveUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetActiveUserReqMultiError) AllErrors() []error { return m }

// GetActiveUserReqValidationError is the validation error returned by
// GetActiveUserReq.Validate if the designated constraints aren't met.
type GetActiveUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetActiveUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetActiveUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetActiveUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetActiveUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetActiveUserReqValidationError) ErrorName() string { return "GetActiveUserReqValidationError" }

// Error satisfies the builtin error interface
func (e GetActiveUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetActiveUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetActiveUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetActiveUserReqValidationError{}

// Validate checks the field values on ActiveUser with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActiveUser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActiveUser with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActiveUserMultiError, or
// nil if none found.
func (m *ActiveUser) ValidateAll() error {
	return m.validate(true)
}

func (m *ActiveUser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActiveUserValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActiveUserValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActiveUserValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Count

	if len(errors) > 0 {
		return ActiveUserMultiError(errors)
	}

	return nil
}

// ActiveUserMultiError is an error wrapping multiple validation errors
// returned by ActiveUser.ValidateAll() if the designated constraints aren't met.
type ActiveUserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActiveUserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActiveUserMultiError) AllErrors() []error { return m }

// ActiveUserValidationError is the validation error returned by
// ActiveUser.Validate if the designated constraints aren't met.
type ActiveUserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActiveUserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActiveUserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActiveUserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActiveUserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActiveUserValidationError) ErrorName() string { return "ActiveUserValidationError" }

// Error satisfies the builtin error interface
func (e ActiveUserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActiveUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActiveUserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActiveUserValidationError{}

// Validate checks the field values on GetActiveUserResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetActiveUserResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetActiveUserResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetActiveUserRespMultiError, or nil if none found.
func (m *GetActiveUserResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetActiveUserResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MsgCount

	// no validation rules for UserCount

	// no validation rules for DateCount

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetActiveUserRespValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetActiveUserRespValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetActiveUserRespValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetActiveUserRespMultiError(errors)
	}

	return nil
}

// GetActiveUserRespMultiError is an error wrapping multiple validation errors
// returned by GetActiveUserResp.ValidateAll() if the designated constraints
// aren't met.
type GetActiveUserRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetActiveUserRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetActiveUserRespMultiError) AllErrors() []error { return m }

// GetActiveUserRespValidationError is the validation error returned by
// GetActiveUserResp.Validate if the designated constraints aren't met.
type GetActiveUserRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetActiveUserRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetActiveUserRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetActiveUserRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetActiveUserRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetActiveUserRespValidationError) ErrorName() string {
	return "GetActiveUserRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetActiveUserRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetActiveUserResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetActiveUserRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetActiveUserRespValidationError{}

// Validate checks the field values on GetActiveGroupReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetActiveGroupReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetActiveGroupReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetActiveGroupReqMultiError, or nil if none found.
func (m *GetActiveGroupReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetActiveGroupReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for Ase

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetActiveGroupReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetActiveGroupReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetActiveGroupReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetActiveGroupReqMultiError(errors)
	}

	return nil
}

// GetActiveGroupReqMultiError is an error wrapping multiple validation errors
// returned by GetActiveGroupReq.ValidateAll() if the designated constraints
// aren't met.
type GetActiveGroupReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetActiveGroupReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetActiveGroupReqMultiError) AllErrors() []error { return m }

// GetActiveGroupReqValidationError is the validation error returned by
// GetActiveGroupReq.Validate if the designated constraints aren't met.
type GetActiveGroupReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetActiveGroupReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetActiveGroupReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetActiveGroupReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetActiveGroupReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetActiveGroupReqValidationError) ErrorName() string {
	return "GetActiveGroupReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetActiveGroupReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetActiveGroupReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetActiveGroupReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetActiveGroupReqValidationError{}

// Validate checks the field values on ActiveGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActiveGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActiveGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActiveGroupMultiError, or
// nil if none found.
func (m *ActiveGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *ActiveGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActiveGroupValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActiveGroupValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActiveGroupValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Count

	if len(errors) > 0 {
		return ActiveGroupMultiError(errors)
	}

	return nil
}

// ActiveGroupMultiError is an error wrapping multiple validation errors
// returned by ActiveGroup.ValidateAll() if the designated constraints aren't met.
type ActiveGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActiveGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActiveGroupMultiError) AllErrors() []error { return m }

// ActiveGroupValidationError is the validation error returned by
// ActiveGroup.Validate if the designated constraints aren't met.
type ActiveGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActiveGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActiveGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActiveGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActiveGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActiveGroupValidationError) ErrorName() string { return "ActiveGroupValidationError" }

// Error satisfies the builtin error interface
func (e ActiveGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActiveGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActiveGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActiveGroupValidationError{}

// Validate checks the field values on GetActiveGroupResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetActiveGroupResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetActiveGroupResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetActiveGroupRespMultiError, or nil if none found.
func (m *GetActiveGroupResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetActiveGroupResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MsgCount

	// no validation rules for GroupCount

	// no validation rules for DateCount

	for idx, item := range m.GetGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetActiveGroupRespValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetActiveGroupRespValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetActiveGroupRespValidationError{
					field:  fmt.Sprintf("Groups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetActiveGroupRespMultiError(errors)
	}

	return nil
}

// GetActiveGroupRespMultiError is an error wrapping multiple validation errors
// returned by GetActiveGroupResp.ValidateAll() if the designated constraints
// aren't met.
type GetActiveGroupRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetActiveGroupRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetActiveGroupRespMultiError) AllErrors() []error { return m }

// GetActiveGroupRespValidationError is the validation error returned by
// GetActiveGroupResp.Validate if the designated constraints aren't met.
type GetActiveGroupRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetActiveGroupRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetActiveGroupRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetActiveGroupRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetActiveGroupRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetActiveGroupRespValidationError) ErrorName() string {
	return "GetActiveGroupRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetActiveGroupRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetActiveGroupResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetActiveGroupRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetActiveGroupRespValidationError{}

// Validate checks the field values on SearchMessageReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SearchMessageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchMessageReqMultiError, or nil if none found.
func (m *SearchMessageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchMessageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SendID

	// no validation rules for RecvID

	// no validation rules for ContentType

	// no validation rules for SendTime

	// no validation rules for SessionType

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchMessageReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchMessageReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchMessageReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SearchMessageReqMultiError(errors)
	}

	return nil
}

// SearchMessageReqMultiError is an error wrapping multiple validation errors
// returned by SearchMessageReq.ValidateAll() if the designated constraints
// aren't met.
type SearchMessageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchMessageReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchMessageReqMultiError) AllErrors() []error { return m }

// SearchMessageReqValidationError is the validation error returned by
// SearchMessageReq.Validate if the designated constraints aren't met.
type SearchMessageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchMessageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchMessageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchMessageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchMessageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchMessageReqValidationError) ErrorName() string { return "SearchMessageReqValidationError" }

// Error satisfies the builtin error interface
func (e SearchMessageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchMessageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchMessageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchMessageReqValidationError{}

// Validate checks the field values on SearchChatLog with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SearchChatLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchChatLog with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SearchChatLogMultiError, or
// nil if none found.
func (m *SearchChatLog) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchChatLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetChatLog()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchChatLogValidationError{
					field:  "ChatLog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchChatLogValidationError{
					field:  "ChatLog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChatLog()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchChatLogValidationError{
				field:  "ChatLog",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsRevoked

	if len(errors) > 0 {
		return SearchChatLogMultiError(errors)
	}

	return nil
}

// SearchChatLogMultiError is an error wrapping multiple validation errors
// returned by SearchChatLog.ValidateAll() if the designated constraints
// aren't met.
type SearchChatLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchChatLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchChatLogMultiError) AllErrors() []error { return m }

// SearchChatLogValidationError is the validation error returned by
// SearchChatLog.Validate if the designated constraints aren't met.
type SearchChatLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchChatLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchChatLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchChatLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchChatLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchChatLogValidationError) ErrorName() string { return "SearchChatLogValidationError" }

// Error satisfies the builtin error interface
func (e SearchChatLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchChatLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchChatLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchChatLogValidationError{}

// Validate checks the field values on SearchedMsgData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SearchedMsgData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchedMsgData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchedMsgDataMultiError, or nil if none found.
func (m *SearchedMsgData) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchedMsgData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMsgData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchedMsgDataValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchedMsgDataValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMsgData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchedMsgDataValidationError{
				field:  "MsgData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsRevoked

	if len(errors) > 0 {
		return SearchedMsgDataMultiError(errors)
	}

	return nil
}

// SearchedMsgDataMultiError is an error wrapping multiple validation errors
// returned by SearchedMsgData.ValidateAll() if the designated constraints
// aren't met.
type SearchedMsgDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchedMsgDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchedMsgDataMultiError) AllErrors() []error { return m }

// SearchedMsgDataValidationError is the validation error returned by
// SearchedMsgData.Validate if the designated constraints aren't met.
type SearchedMsgDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchedMsgDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchedMsgDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchedMsgDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchedMsgDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchedMsgDataValidationError) ErrorName() string { return "SearchedMsgDataValidationError" }

// Error satisfies the builtin error interface
func (e SearchedMsgDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchedMsgData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchedMsgDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchedMsgDataValidationError{}

// Validate checks the field values on SearchMessageResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SearchMessageResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchMessageResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchMessageRespMultiError, or nil if none found.
func (m *SearchMessageResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchMessageResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetChatLogs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchMessageRespValidationError{
						field:  fmt.Sprintf("ChatLogs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchMessageRespValidationError{
						field:  fmt.Sprintf("ChatLogs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchMessageRespValidationError{
					field:  fmt.Sprintf("ChatLogs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ChatLogsNum

	if len(errors) > 0 {
		return SearchMessageRespMultiError(errors)
	}

	return nil
}

// SearchMessageRespMultiError is an error wrapping multiple validation errors
// returned by SearchMessageResp.ValidateAll() if the designated constraints
// aren't met.
type SearchMessageRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchMessageRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchMessageRespMultiError) AllErrors() []error { return m }

// SearchMessageRespValidationError is the validation error returned by
// SearchMessageResp.Validate if the designated constraints aren't met.
type SearchMessageRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchMessageRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchMessageRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchMessageRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchMessageRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchMessageRespValidationError) ErrorName() string {
	return "SearchMessageRespValidationError"
}

// Error satisfies the builtin error interface
func (e SearchMessageRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchMessageResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchMessageRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchMessageRespValidationError{}

// Validate checks the field values on ChatLog with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChatLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChatLog with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ChatLogMultiError, or nil if none found.
func (m *ChatLog) ValidateAll() error {
	return m.validate(true)
}

func (m *ChatLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServerMsgID

	// no validation rules for ClientMsgID

	// no validation rules for SendID

	// no validation rules for RecvID

	// no validation rules for GroupID

	// no validation rules for RecvNickname

	// no validation rules for SenderPlatformID

	// no validation rules for SenderNickname

	// no validation rules for SenderFaceURL

	// no validation rules for GroupName

	// no validation rules for SessionType

	// no validation rules for MsgFrom

	// no validation rules for ContentType

	// no validation rules for Content

	// no validation rules for Status

	// no validation rules for SendTime

	// no validation rules for CreateTime

	// no validation rules for Ex

	// no validation rules for GroupFaceURL

	// no validation rules for GroupMemberCount

	// no validation rules for Seq

	// no validation rules for GroupOwner

	// no validation rules for GroupType

	if len(errors) > 0 {
		return ChatLogMultiError(errors)
	}

	return nil
}

// ChatLogMultiError is an error wrapping multiple validation errors returned
// by ChatLog.ValidateAll() if the designated constraints aren't met.
type ChatLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChatLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChatLogMultiError) AllErrors() []error { return m }

// ChatLogValidationError is the validation error returned by ChatLog.Validate
// if the designated constraints aren't met.
type ChatLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChatLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChatLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChatLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChatLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChatLogValidationError) ErrorName() string { return "ChatLogValidationError" }

// Error satisfies the builtin error interface
func (e ChatLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChatLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChatLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChatLogValidationError{}

// Validate checks the field values on BatchSendMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchSendMessageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchSendMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchSendMessageReqMultiError, or nil if none found.
func (m *BatchSendMessageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchSendMessageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMsgData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchSendMessageReqValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchSendMessageReqValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMsgData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchSendMessageReqValidationError{
				field:  "MsgData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchSendMessageReqMultiError(errors)
	}

	return nil
}

// BatchSendMessageReqMultiError is an error wrapping multiple validation
// errors returned by BatchSendMessageReq.ValidateAll() if the designated
// constraints aren't met.
type BatchSendMessageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchSendMessageReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchSendMessageReqMultiError) AllErrors() []error { return m }

// BatchSendMessageReqValidationError is the validation error returned by
// BatchSendMessageReq.Validate if the designated constraints aren't met.
type BatchSendMessageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchSendMessageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchSendMessageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchSendMessageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchSendMessageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchSendMessageReqValidationError) ErrorName() string {
	return "BatchSendMessageReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchSendMessageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchSendMessageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchSendMessageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchSendMessageReqValidationError{}

// Validate checks the field values on BatchSendMessageResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchSendMessageResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchSendMessageResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchSendMessageRespMultiError, or nil if none found.
func (m *BatchSendMessageResp) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchSendMessageResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BatchSendMessageRespMultiError(errors)
	}

	return nil
}

// BatchSendMessageRespMultiError is an error wrapping multiple validation
// errors returned by BatchSendMessageResp.ValidateAll() if the designated
// constraints aren't met.
type BatchSendMessageRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchSendMessageRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchSendMessageRespMultiError) AllErrors() []error { return m }

// BatchSendMessageRespValidationError is the validation error returned by
// BatchSendMessageResp.Validate if the designated constraints aren't met.
type BatchSendMessageRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchSendMessageRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchSendMessageRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchSendMessageRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchSendMessageRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchSendMessageRespValidationError) ErrorName() string {
	return "BatchSendMessageRespValidationError"
}

// Error satisfies the builtin error interface
func (e BatchSendMessageRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchSendMessageResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchSendMessageRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchSendMessageRespValidationError{}

// Validate checks the field values on GetServerTimeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetServerTimeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServerTimeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServerTimeReqMultiError, or nil if none found.
func (m *GetServerTimeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServerTimeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetServerTimeReqMultiError(errors)
	}

	return nil
}

// GetServerTimeReqMultiError is an error wrapping multiple validation errors
// returned by GetServerTimeReq.ValidateAll() if the designated constraints
// aren't met.
type GetServerTimeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServerTimeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServerTimeReqMultiError) AllErrors() []error { return m }

// GetServerTimeReqValidationError is the validation error returned by
// GetServerTimeReq.Validate if the designated constraints aren't met.
type GetServerTimeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServerTimeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServerTimeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServerTimeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServerTimeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServerTimeReqValidationError) ErrorName() string { return "GetServerTimeReqValidationError" }

// Error satisfies the builtin error interface
func (e GetServerTimeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServerTimeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServerTimeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServerTimeReqValidationError{}

// Validate checks the field values on GetServerTimeResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetServerTimeResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetServerTimeResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetServerTimeRespMultiError, or nil if none found.
func (m *GetServerTimeResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetServerTimeResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServerTime

	if len(errors) > 0 {
		return GetServerTimeRespMultiError(errors)
	}

	return nil
}

// GetServerTimeRespMultiError is an error wrapping multiple validation errors
// returned by GetServerTimeResp.ValidateAll() if the designated constraints
// aren't met.
type GetServerTimeRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetServerTimeRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetServerTimeRespMultiError) AllErrors() []error { return m }

// GetServerTimeRespValidationError is the validation error returned by
// GetServerTimeResp.Validate if the designated constraints aren't met.
type GetServerTimeRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServerTimeRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServerTimeRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServerTimeRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServerTimeRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServerTimeRespValidationError) ErrorName() string {
	return "GetServerTimeRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetServerTimeRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServerTimeResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServerTimeRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServerTimeRespValidationError{}

// Validate checks the field values on ClearMsgReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClearMsgReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClearMsgReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClearMsgReqMultiError, or
// nil if none found.
func (m *ClearMsgReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ClearMsgReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return ClearMsgReqMultiError(errors)
	}

	return nil
}

// ClearMsgReqMultiError is an error wrapping multiple validation errors
// returned by ClearMsgReq.ValidateAll() if the designated constraints aren't met.
type ClearMsgReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClearMsgReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClearMsgReqMultiError) AllErrors() []error { return m }

// ClearMsgReqValidationError is the validation error returned by
// ClearMsgReq.Validate if the designated constraints aren't met.
type ClearMsgReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClearMsgReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClearMsgReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClearMsgReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClearMsgReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClearMsgReqValidationError) ErrorName() string { return "ClearMsgReqValidationError" }

// Error satisfies the builtin error interface
func (e ClearMsgReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClearMsgReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClearMsgReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClearMsgReqValidationError{}

// Validate checks the field values on ClearMsgResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClearMsgResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClearMsgResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClearMsgRespMultiError, or
// nil if none found.
func (m *ClearMsgResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ClearMsgResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ClearMsgRespMultiError(errors)
	}

	return nil
}

// ClearMsgRespMultiError is an error wrapping multiple validation errors
// returned by ClearMsgResp.ValidateAll() if the designated constraints aren't met.
type ClearMsgRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClearMsgRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClearMsgRespMultiError) AllErrors() []error { return m }

// ClearMsgRespValidationError is the validation error returned by
// ClearMsgResp.Validate if the designated constraints aren't met.
type ClearMsgRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClearMsgRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClearMsgRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClearMsgRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClearMsgRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClearMsgRespValidationError) ErrorName() string { return "ClearMsgRespValidationError" }

// Error satisfies the builtin error interface
func (e ClearMsgRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClearMsgResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClearMsgRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClearMsgRespValidationError{}

// Validate checks the field values on DestructMsgsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DestructMsgsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DestructMsgsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DestructMsgsReqMultiError, or nil if none found.
func (m *DestructMsgsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DestructMsgsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConversations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DestructMsgsReqValidationError{
						field:  fmt.Sprintf("Conversations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DestructMsgsReqValidationError{
						field:  fmt.Sprintf("Conversations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DestructMsgsReqValidationError{
					field:  fmt.Sprintf("Conversations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DestructMsgsReqMultiError(errors)
	}

	return nil
}

// DestructMsgsReqMultiError is an error wrapping multiple validation errors
// returned by DestructMsgsReq.ValidateAll() if the designated constraints
// aren't met.
type DestructMsgsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DestructMsgsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DestructMsgsReqMultiError) AllErrors() []error { return m }

// DestructMsgsReqValidationError is the validation error returned by
// DestructMsgsReq.Validate if the designated constraints aren't met.
type DestructMsgsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DestructMsgsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DestructMsgsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DestructMsgsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DestructMsgsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DestructMsgsReqValidationError) ErrorName() string { return "DestructMsgsReqValidationError" }

// Error satisfies the builtin error interface
func (e DestructMsgsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDestructMsgsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DestructMsgsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DestructMsgsReqValidationError{}

// Validate checks the field values on DestructMsgsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DestructMsgsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DestructMsgsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DestructMsgsRespMultiError, or nil if none found.
func (m *DestructMsgsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DestructMsgsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DestructMsgsRespMultiError(errors)
	}

	return nil
}

// DestructMsgsRespMultiError is an error wrapping multiple validation errors
// returned by DestructMsgsResp.ValidateAll() if the designated constraints
// aren't met.
type DestructMsgsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DestructMsgsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DestructMsgsRespMultiError) AllErrors() []error { return m }

// DestructMsgsRespValidationError is the validation error returned by
// DestructMsgsResp.Validate if the designated constraints aren't met.
type DestructMsgsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DestructMsgsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DestructMsgsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DestructMsgsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DestructMsgsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DestructMsgsRespValidationError) ErrorName() string { return "DestructMsgsRespValidationError" }

// Error satisfies the builtin error interface
func (e DestructMsgsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDestructMsgsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DestructMsgsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DestructMsgsRespValidationError{}

// Validate checks the field values on SetUserConversationsMinSeqReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetUserConversationsMinSeqReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetUserConversationsMinSeqReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SetUserConversationsMinSeqReqMultiError, or nil if none found.
func (m *SetUserConversationsMinSeqReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetUserConversationsMinSeqReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	// no validation rules for Seq

	if len(errors) > 0 {
		return SetUserConversationsMinSeqReqMultiError(errors)
	}

	return nil
}

// SetUserConversationsMinSeqReqMultiError is an error wrapping multiple
// validation errors returned by SetUserConversationsMinSeqReq.ValidateAll()
// if the designated constraints aren't met.
type SetUserConversationsMinSeqReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetUserConversationsMinSeqReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetUserConversationsMinSeqReqMultiError) AllErrors() []error { return m }

// SetUserConversationsMinSeqReqValidationError is the validation error
// returned by SetUserConversationsMinSeqReq.Validate if the designated
// constraints aren't met.
type SetUserConversationsMinSeqReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetUserConversationsMinSeqReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetUserConversationsMinSeqReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetUserConversationsMinSeqReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetUserConversationsMinSeqReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetUserConversationsMinSeqReqValidationError) ErrorName() string {
	return "SetUserConversationsMinSeqReqValidationError"
}

// Error satisfies the builtin error interface
func (e SetUserConversationsMinSeqReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetUserConversationsMinSeqReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetUserConversationsMinSeqReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetUserConversationsMinSeqReqValidationError{}

// Validate checks the field values on SetUserConversationsMinSeqResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetUserConversationsMinSeqResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetUserConversationsMinSeqResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SetUserConversationsMinSeqRespMultiError, or nil if none found.
func (m *SetUserConversationsMinSeqResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SetUserConversationsMinSeqResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetUserConversationsMinSeqRespMultiError(errors)
	}

	return nil
}

// SetUserConversationsMinSeqRespMultiError is an error wrapping multiple
// validation errors returned by SetUserConversationsMinSeqResp.ValidateAll()
// if the designated constraints aren't met.
type SetUserConversationsMinSeqRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetUserConversationsMinSeqRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetUserConversationsMinSeqRespMultiError) AllErrors() []error { return m }

// SetUserConversationsMinSeqRespValidationError is the validation error
// returned by SetUserConversationsMinSeqResp.Validate if the designated
// constraints aren't met.
type SetUserConversationsMinSeqRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetUserConversationsMinSeqRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetUserConversationsMinSeqRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetUserConversationsMinSeqRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetUserConversationsMinSeqRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetUserConversationsMinSeqRespValidationError) ErrorName() string {
	return "SetUserConversationsMinSeqRespValidationError"
}

// Error satisfies the builtin error interface
func (e SetUserConversationsMinSeqRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetUserConversationsMinSeqResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetUserConversationsMinSeqRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetUserConversationsMinSeqRespValidationError{}

// Validate checks the field values on ConversationSeqs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConversationSeqs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConversationSeqs with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConversationSeqsMultiError, or nil if none found.
func (m *ConversationSeqs) ValidateAll() error {
	return m.validate(true)
}

func (m *ConversationSeqs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	if len(errors) > 0 {
		return ConversationSeqsMultiError(errors)
	}

	return nil
}

// ConversationSeqsMultiError is an error wrapping multiple validation errors
// returned by ConversationSeqs.ValidateAll() if the designated constraints
// aren't met.
type ConversationSeqsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConversationSeqsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConversationSeqsMultiError) AllErrors() []error { return m }

// ConversationSeqsValidationError is the validation error returned by
// ConversationSeqs.Validate if the designated constraints aren't met.
type ConversationSeqsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConversationSeqsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConversationSeqsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConversationSeqsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConversationSeqsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConversationSeqsValidationError) ErrorName() string { return "ConversationSeqsValidationError" }

// Error satisfies the builtin error interface
func (e ConversationSeqsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConversationSeqs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConversationSeqsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConversationSeqsValidationError{}

// Validate checks the field values on GetSeqMessageReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSeqMessageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSeqMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSeqMessageReqMultiError, or nil if none found.
func (m *GetSeqMessageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSeqMessageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	for idx, item := range m.GetConversations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSeqMessageReqValidationError{
						field:  fmt.Sprintf("Conversations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSeqMessageReqValidationError{
						field:  fmt.Sprintf("Conversations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSeqMessageReqValidationError{
					field:  fmt.Sprintf("Conversations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSeqMessageReqMultiError(errors)
	}

	return nil
}

// GetSeqMessageReqMultiError is an error wrapping multiple validation errors
// returned by GetSeqMessageReq.ValidateAll() if the designated constraints
// aren't met.
type GetSeqMessageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSeqMessageReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSeqMessageReqMultiError) AllErrors() []error { return m }

// GetSeqMessageReqValidationError is the validation error returned by
// GetSeqMessageReq.Validate if the designated constraints aren't met.
type GetSeqMessageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSeqMessageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSeqMessageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSeqMessageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSeqMessageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSeqMessageReqValidationError) ErrorName() string { return "GetSeqMessageReqValidationError" }

// Error satisfies the builtin error interface
func (e GetSeqMessageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSeqMessageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSeqMessageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSeqMessageReqValidationError{}

// Validate checks the field values on GetSeqMessageResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSeqMessageResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSeqMessageResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSeqMessageRespMultiError, or nil if none found.
func (m *GetSeqMessageResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSeqMessageResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetMsgs()))
		i := 0
		for key := range m.GetMsgs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMsgs()[key]
			_ = val

			// no validation rules for Msgs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetSeqMessageRespValidationError{
							field:  fmt.Sprintf("Msgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetSeqMessageRespValidationError{
							field:  fmt.Sprintf("Msgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetSeqMessageRespValidationError{
						field:  fmt.Sprintf("Msgs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetNotificationMsgs()))
		i := 0
		for key := range m.GetNotificationMsgs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetNotificationMsgs()[key]
			_ = val

			// no validation rules for NotificationMsgs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetSeqMessageRespValidationError{
							field:  fmt.Sprintf("NotificationMsgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetSeqMessageRespValidationError{
							field:  fmt.Sprintf("NotificationMsgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetSeqMessageRespValidationError{
						field:  fmt.Sprintf("NotificationMsgs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetSeqMessageRespMultiError(errors)
	}

	return nil
}

// GetSeqMessageRespMultiError is an error wrapping multiple validation errors
// returned by GetSeqMessageResp.ValidateAll() if the designated constraints
// aren't met.
type GetSeqMessageRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSeqMessageRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSeqMessageRespMultiError) AllErrors() []error { return m }

// GetSeqMessageRespValidationError is the validation error returned by
// GetSeqMessageResp.Validate if the designated constraints aren't met.
type GetSeqMessageRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSeqMessageRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSeqMessageRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSeqMessageRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSeqMessageRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSeqMessageRespValidationError) ErrorName() string {
	return "GetSeqMessageRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetSeqMessageRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSeqMessageResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSeqMessageRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSeqMessageRespValidationError{}

// Validate checks the field values on GetActiveConversationReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetActiveConversationReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetActiveConversationReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetActiveConversationReqMultiError, or nil if none found.
func (m *GetActiveConversationReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetActiveConversationReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	if len(errors) > 0 {
		return GetActiveConversationReqMultiError(errors)
	}

	return nil
}

// GetActiveConversationReqMultiError is an error wrapping multiple validation
// errors returned by GetActiveConversationReq.ValidateAll() if the designated
// constraints aren't met.
type GetActiveConversationReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetActiveConversationReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetActiveConversationReqMultiError) AllErrors() []error { return m }

// GetActiveConversationReqValidationError is the validation error returned by
// GetActiveConversationReq.Validate if the designated constraints aren't met.
type GetActiveConversationReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetActiveConversationReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetActiveConversationReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetActiveConversationReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetActiveConversationReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetActiveConversationReqValidationError) ErrorName() string {
	return "GetActiveConversationReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetActiveConversationReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetActiveConversationReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetActiveConversationReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetActiveConversationReqValidationError{}

// Validate checks the field values on ActiveConversation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActiveConversation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActiveConversation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActiveConversationMultiError, or nil if none found.
func (m *ActiveConversation) ValidateAll() error {
	return m.validate(true)
}

func (m *ActiveConversation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	// no validation rules for LastTime

	// no validation rules for MaxSeq

	if len(errors) > 0 {
		return ActiveConversationMultiError(errors)
	}

	return nil
}

// ActiveConversationMultiError is an error wrapping multiple validation errors
// returned by ActiveConversation.ValidateAll() if the designated constraints
// aren't met.
type ActiveConversationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActiveConversationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActiveConversationMultiError) AllErrors() []error { return m }

// ActiveConversationValidationError is the validation error returned by
// ActiveConversation.Validate if the designated constraints aren't met.
type ActiveConversationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActiveConversationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActiveConversationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActiveConversationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActiveConversationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActiveConversationValidationError) ErrorName() string {
	return "ActiveConversationValidationError"
}

// Error satisfies the builtin error interface
func (e ActiveConversationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActiveConversation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActiveConversationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActiveConversationValidationError{}

// Validate checks the field values on GetActiveConversationResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetActiveConversationResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetActiveConversationResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetActiveConversationRespMultiError, or nil if none found.
func (m *GetActiveConversationResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetActiveConversationResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConversations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetActiveConversationRespValidationError{
						field:  fmt.Sprintf("Conversations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetActiveConversationRespValidationError{
						field:  fmt.Sprintf("Conversations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetActiveConversationRespValidationError{
					field:  fmt.Sprintf("Conversations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetActiveConversationRespMultiError(errors)
	}

	return nil
}

// GetActiveConversationRespMultiError is an error wrapping multiple validation
// errors returned by GetActiveConversationResp.ValidateAll() if the
// designated constraints aren't met.
type GetActiveConversationRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetActiveConversationRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetActiveConversationRespMultiError) AllErrors() []error { return m }

// GetActiveConversationRespValidationError is the validation error returned by
// GetActiveConversationResp.Validate if the designated constraints aren't met.
type GetActiveConversationRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetActiveConversationRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetActiveConversationRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetActiveConversationRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetActiveConversationRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetActiveConversationRespValidationError) ErrorName() string {
	return "GetActiveConversationRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetActiveConversationRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetActiveConversationResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetActiveConversationRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetActiveConversationRespValidationError{}
