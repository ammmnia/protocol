// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: rtc/rtc.proto

package rtc

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ParticipantMetaData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParticipantMetaData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParticipantMetaData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParticipantMetaDataMultiError, or nil if none found.
func (m *ParticipantMetaData) ValidateAll() error {
	return m.validate(true)
}

func (m *ParticipantMetaData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroupInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParticipantMetaDataValidationError{
					field:  "GroupInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParticipantMetaDataValidationError{
					field:  "GroupInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroupInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParticipantMetaDataValidationError{
				field:  "GroupInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroupMemberInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParticipantMetaDataValidationError{
					field:  "GroupMemberInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParticipantMetaDataValidationError{
					field:  "GroupMemberInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroupMemberInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParticipantMetaDataValidationError{
				field:  "GroupMemberInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUserInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParticipantMetaDataValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParticipantMetaDataValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParticipantMetaDataValidationError{
				field:  "UserInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParticipantMetaDataMultiError(errors)
	}

	return nil
}

// ParticipantMetaDataMultiError is an error wrapping multiple validation
// errors returned by ParticipantMetaData.ValidateAll() if the designated
// constraints aren't met.
type ParticipantMetaDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParticipantMetaDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParticipantMetaDataMultiError) AllErrors() []error { return m }

// ParticipantMetaDataValidationError is the validation error returned by
// ParticipantMetaData.Validate if the designated constraints aren't met.
type ParticipantMetaDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParticipantMetaDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParticipantMetaDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParticipantMetaDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParticipantMetaDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParticipantMetaDataValidationError) ErrorName() string {
	return "ParticipantMetaDataValidationError"
}

// Error satisfies the builtin error interface
func (e ParticipantMetaDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParticipantMetaData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParticipantMetaDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParticipantMetaDataValidationError{}

// Validate checks the field values on GetJoinTokenReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetJoinTokenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetJoinTokenReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetJoinTokenReqMultiError, or nil if none found.
func (m *GetJoinTokenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetJoinTokenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Room

	// no validation rules for Identity

	if all {
		switch v := interface{}(m.GetMetaData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetJoinTokenReqValidationError{
					field:  "MetaData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetJoinTokenReqValidationError{
					field:  "MetaData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetaData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetJoinTokenReqValidationError{
				field:  "MetaData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetJoinTokenReqMultiError(errors)
	}

	return nil
}

// GetJoinTokenReqMultiError is an error wrapping multiple validation errors
// returned by GetJoinTokenReq.ValidateAll() if the designated constraints
// aren't met.
type GetJoinTokenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetJoinTokenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetJoinTokenReqMultiError) AllErrors() []error { return m }

// GetJoinTokenReqValidationError is the validation error returned by
// GetJoinTokenReq.Validate if the designated constraints aren't met.
type GetJoinTokenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetJoinTokenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetJoinTokenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetJoinTokenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetJoinTokenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetJoinTokenReqValidationError) ErrorName() string { return "GetJoinTokenReqValidationError" }

// Error satisfies the builtin error interface
func (e GetJoinTokenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetJoinTokenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetJoinTokenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetJoinTokenReqValidationError{}

// Validate checks the field values on GetJoinTokenResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetJoinTokenResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetJoinTokenResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetJoinTokenRespMultiError, or nil if none found.
func (m *GetJoinTokenResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetJoinTokenResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Jwt

	// no validation rules for LiveURL

	if len(errors) > 0 {
		return GetJoinTokenRespMultiError(errors)
	}

	return nil
}

// GetJoinTokenRespMultiError is an error wrapping multiple validation errors
// returned by GetJoinTokenResp.ValidateAll() if the designated constraints
// aren't met.
type GetJoinTokenRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetJoinTokenRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetJoinTokenRespMultiError) AllErrors() []error { return m }

// GetJoinTokenRespValidationError is the validation error returned by
// GetJoinTokenResp.Validate if the designated constraints aren't met.
type GetJoinTokenRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetJoinTokenRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetJoinTokenRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetJoinTokenRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetJoinTokenRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetJoinTokenRespValidationError) ErrorName() string { return "GetJoinTokenRespValidationError" }

// Error satisfies the builtin error interface
func (e GetJoinTokenRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetJoinTokenResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetJoinTokenRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetJoinTokenRespValidationError{}

// Validate checks the field values on SignalReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignalReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignalReqMultiError, or nil
// if none found.
func (m *SignalReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *SignalReq_Invite:
		if v == nil {
			err := SignalReqValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInvite()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "Invite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "Invite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInvite()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalReqValidationError{
					field:  "Invite",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalReq_InviteInGroup:
		if v == nil {
			err := SignalReqValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInviteInGroup()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "InviteInGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "InviteInGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInviteInGroup()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalReqValidationError{
					field:  "InviteInGroup",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalReq_Cancel:
		if v == nil {
			err := SignalReqValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCancel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "Cancel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "Cancel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCancel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalReqValidationError{
					field:  "Cancel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalReq_Accept:
		if v == nil {
			err := SignalReqValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAccept()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "Accept",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "Accept",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAccept()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalReqValidationError{
					field:  "Accept",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalReq_HungUp:
		if v == nil {
			err := SignalReqValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHungUp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "HungUp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "HungUp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHungUp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalReqValidationError{
					field:  "HungUp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalReq_Reject:
		if v == nil {
			err := SignalReqValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReject()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "Reject",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "Reject",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReject()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalReqValidationError{
					field:  "Reject",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalReq_GetTokenByRoomID:
		if v == nil {
			err := SignalReqValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetTokenByRoomID()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "GetTokenByRoomID",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalReqValidationError{
						field:  "GetTokenByRoomID",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetTokenByRoomID()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalReqValidationError{
					field:  "GetTokenByRoomID",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SignalReqMultiError(errors)
	}

	return nil
}

// SignalReqMultiError is an error wrapping multiple validation errors returned
// by SignalReq.ValidateAll() if the designated constraints aren't met.
type SignalReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalReqMultiError) AllErrors() []error { return m }

// SignalReqValidationError is the validation error returned by
// SignalReq.Validate if the designated constraints aren't met.
type SignalReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalReqValidationError) ErrorName() string { return "SignalReqValidationError" }

// Error satisfies the builtin error interface
func (e SignalReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalReqValidationError{}

// Validate checks the field values on SignalSendCustomSignalReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalSendCustomSignalReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalSendCustomSignalReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalSendCustomSignalReqMultiError, or nil if none found.
func (m *SignalSendCustomSignalReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalSendCustomSignalReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoomID

	// no validation rules for CustomInfo

	if len(errors) > 0 {
		return SignalSendCustomSignalReqMultiError(errors)
	}

	return nil
}

// SignalSendCustomSignalReqMultiError is an error wrapping multiple validation
// errors returned by SignalSendCustomSignalReq.ValidateAll() if the
// designated constraints aren't met.
type SignalSendCustomSignalReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalSendCustomSignalReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalSendCustomSignalReqMultiError) AllErrors() []error { return m }

// SignalSendCustomSignalReqValidationError is the validation error returned by
// SignalSendCustomSignalReq.Validate if the designated constraints aren't met.
type SignalSendCustomSignalReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalSendCustomSignalReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalSendCustomSignalReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalSendCustomSignalReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalSendCustomSignalReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalSendCustomSignalReqValidationError) ErrorName() string {
	return "SignalSendCustomSignalReqValidationError"
}

// Error satisfies the builtin error interface
func (e SignalSendCustomSignalReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalSendCustomSignalReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalSendCustomSignalReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalSendCustomSignalReqValidationError{}

// Validate checks the field values on SignalSendCustomSignalResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalSendCustomSignalResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalSendCustomSignalResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalSendCustomSignalRespMultiError, or nil if none found.
func (m *SignalSendCustomSignalResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalSendCustomSignalResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SignalSendCustomSignalRespMultiError(errors)
	}

	return nil
}

// SignalSendCustomSignalRespMultiError is an error wrapping multiple
// validation errors returned by SignalSendCustomSignalResp.ValidateAll() if
// the designated constraints aren't met.
type SignalSendCustomSignalRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalSendCustomSignalRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalSendCustomSignalRespMultiError) AllErrors() []error { return m }

// SignalSendCustomSignalRespValidationError is the validation error returned
// by SignalSendCustomSignalResp.Validate if the designated constraints aren't met.
type SignalSendCustomSignalRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalSendCustomSignalRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalSendCustomSignalRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalSendCustomSignalRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalSendCustomSignalRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalSendCustomSignalRespValidationError) ErrorName() string {
	return "SignalSendCustomSignalRespValidationError"
}

// Error satisfies the builtin error interface
func (e SignalSendCustomSignalRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalSendCustomSignalResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalSendCustomSignalRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalSendCustomSignalRespValidationError{}

// Validate checks the field values on SignalOnStreamChangeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalOnStreamChangeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalOnStreamChangeReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalOnStreamChangeReqMultiError, or nil if none found.
func (m *SignalOnStreamChangeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalOnStreamChangeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoomID

	// no validation rules for StreamType

	// no validation rules for Mute

	if len(errors) > 0 {
		return SignalOnStreamChangeReqMultiError(errors)
	}

	return nil
}

// SignalOnStreamChangeReqMultiError is an error wrapping multiple validation
// errors returned by SignalOnStreamChangeReq.ValidateAll() if the designated
// constraints aren't met.
type SignalOnStreamChangeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalOnStreamChangeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalOnStreamChangeReqMultiError) AllErrors() []error { return m }

// SignalOnStreamChangeReqValidationError is the validation error returned by
// SignalOnStreamChangeReq.Validate if the designated constraints aren't met.
type SignalOnStreamChangeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalOnStreamChangeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalOnStreamChangeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalOnStreamChangeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalOnStreamChangeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalOnStreamChangeReqValidationError) ErrorName() string {
	return "SignalOnStreamChangeReqValidationError"
}

// Error satisfies the builtin error interface
func (e SignalOnStreamChangeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalOnStreamChangeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalOnStreamChangeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalOnStreamChangeReqValidationError{}

// Validate checks the field values on SignalResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignalResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignalRespMultiError, or
// nil if none found.
func (m *SignalResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *SignalResp_Invite:
		if v == nil {
			err := SignalRespValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInvite()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "Invite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "Invite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInvite()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRespValidationError{
					field:  "Invite",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResp_InviteInGroup:
		if v == nil {
			err := SignalRespValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInviteInGroup()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "InviteInGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "InviteInGroup",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInviteInGroup()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRespValidationError{
					field:  "InviteInGroup",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResp_Cancel:
		if v == nil {
			err := SignalRespValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCancel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "Cancel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "Cancel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCancel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRespValidationError{
					field:  "Cancel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResp_Accept:
		if v == nil {
			err := SignalRespValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAccept()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "Accept",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "Accept",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAccept()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRespValidationError{
					field:  "Accept",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResp_HungUp:
		if v == nil {
			err := SignalRespValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHungUp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "HungUp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "HungUp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHungUp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRespValidationError{
					field:  "HungUp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResp_Reject:
		if v == nil {
			err := SignalRespValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReject()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "Reject",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "Reject",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReject()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRespValidationError{
					field:  "Reject",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SignalResp_GetTokenByRoomID:
		if v == nil {
			err := SignalRespValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetTokenByRoomID()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "GetTokenByRoomID",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRespValidationError{
						field:  "GetTokenByRoomID",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetTokenByRoomID()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRespValidationError{
					field:  "GetTokenByRoomID",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SignalRespMultiError(errors)
	}

	return nil
}

// SignalRespMultiError is an error wrapping multiple validation errors
// returned by SignalResp.ValidateAll() if the designated constraints aren't met.
type SignalRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalRespMultiError) AllErrors() []error { return m }

// SignalRespValidationError is the validation error returned by
// SignalResp.Validate if the designated constraints aren't met.
type SignalRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalRespValidationError) ErrorName() string { return "SignalRespValidationError" }

// Error satisfies the builtin error interface
func (e SignalRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalRespValidationError{}

// Validate checks the field values on InvitationInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvitationInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvitationInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvitationInfoMultiError,
// or nil if none found.
func (m *InvitationInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *InvitationInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InviterUserID

	// no validation rules for CustomData

	// no validation rules for GroupID

	// no validation rules for RoomID

	// no validation rules for Timeout

	// no validation rules for MediaType

	// no validation rules for PlatformID

	// no validation rules for SessionType

	// no validation rules for InitiateTime

	if len(errors) > 0 {
		return InvitationInfoMultiError(errors)
	}

	return nil
}

// InvitationInfoMultiError is an error wrapping multiple validation errors
// returned by InvitationInfo.ValidateAll() if the designated constraints
// aren't met.
type InvitationInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvitationInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvitationInfoMultiError) AllErrors() []error { return m }

// InvitationInfoValidationError is the validation error returned by
// InvitationInfo.Validate if the designated constraints aren't met.
type InvitationInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvitationInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvitationInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvitationInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvitationInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvitationInfoValidationError) ErrorName() string { return "InvitationInfoValidationError" }

// Error satisfies the builtin error interface
func (e InvitationInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvitationInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvitationInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvitationInfoValidationError{}

// Validate checks the field values on SignalInviteReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalInviteReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalInviteReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalInviteReqMultiError, or nil if none found.
func (m *SignalInviteReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalInviteReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalInviteReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalInviteReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalInviteReqValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfflinePushInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalInviteReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalInviteReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfflinePushInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalInviteReqValidationError{
				field:  "OfflinePushInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParticipant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalInviteReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalInviteReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParticipant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalInviteReqValidationError{
				field:  "Participant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserID

	if len(errors) > 0 {
		return SignalInviteReqMultiError(errors)
	}

	return nil
}

// SignalInviteReqMultiError is an error wrapping multiple validation errors
// returned by SignalInviteReq.ValidateAll() if the designated constraints
// aren't met.
type SignalInviteReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalInviteReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalInviteReqMultiError) AllErrors() []error { return m }

// SignalInviteReqValidationError is the validation error returned by
// SignalInviteReq.Validate if the designated constraints aren't met.
type SignalInviteReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalInviteReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalInviteReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalInviteReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalInviteReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalInviteReqValidationError) ErrorName() string { return "SignalInviteReqValidationError" }

// Error satisfies the builtin error interface
func (e SignalInviteReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalInviteReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalInviteReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalInviteReqValidationError{}

// Validate checks the field values on SignalInviteResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalInviteResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalInviteResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalInviteRespMultiError, or nil if none found.
func (m *SignalInviteResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalInviteResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for RoomID

	// no validation rules for LiveURL

	if len(errors) > 0 {
		return SignalInviteRespMultiError(errors)
	}

	return nil
}

// SignalInviteRespMultiError is an error wrapping multiple validation errors
// returned by SignalInviteResp.ValidateAll() if the designated constraints
// aren't met.
type SignalInviteRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalInviteRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalInviteRespMultiError) AllErrors() []error { return m }

// SignalInviteRespValidationError is the validation error returned by
// SignalInviteResp.Validate if the designated constraints aren't met.
type SignalInviteRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalInviteRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalInviteRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalInviteRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalInviteRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalInviteRespValidationError) ErrorName() string { return "SignalInviteRespValidationError" }

// Error satisfies the builtin error interface
func (e SignalInviteRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalInviteResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalInviteRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalInviteRespValidationError{}

// Validate checks the field values on SignalInviteInGroupReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalInviteInGroupReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalInviteInGroupReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalInviteInGroupReqMultiError, or nil if none found.
func (m *SignalInviteInGroupReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalInviteInGroupReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalInviteInGroupReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalInviteInGroupReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalInviteInGroupReqValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfflinePushInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalInviteInGroupReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalInviteInGroupReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfflinePushInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalInviteInGroupReqValidationError{
				field:  "OfflinePushInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParticipant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalInviteInGroupReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalInviteInGroupReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParticipant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalInviteInGroupReqValidationError{
				field:  "Participant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserID

	if len(errors) > 0 {
		return SignalInviteInGroupReqMultiError(errors)
	}

	return nil
}

// SignalInviteInGroupReqMultiError is an error wrapping multiple validation
// errors returned by SignalInviteInGroupReq.ValidateAll() if the designated
// constraints aren't met.
type SignalInviteInGroupReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalInviteInGroupReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalInviteInGroupReqMultiError) AllErrors() []error { return m }

// SignalInviteInGroupReqValidationError is the validation error returned by
// SignalInviteInGroupReq.Validate if the designated constraints aren't met.
type SignalInviteInGroupReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalInviteInGroupReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalInviteInGroupReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalInviteInGroupReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalInviteInGroupReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalInviteInGroupReqValidationError) ErrorName() string {
	return "SignalInviteInGroupReqValidationError"
}

// Error satisfies the builtin error interface
func (e SignalInviteInGroupReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalInviteInGroupReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalInviteInGroupReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalInviteInGroupReqValidationError{}

// Validate checks the field values on SignalInviteInGroupResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalInviteInGroupResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalInviteInGroupResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalInviteInGroupRespMultiError, or nil if none found.
func (m *SignalInviteInGroupResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalInviteInGroupResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for RoomID

	// no validation rules for LiveURL

	if len(errors) > 0 {
		return SignalInviteInGroupRespMultiError(errors)
	}

	return nil
}

// SignalInviteInGroupRespMultiError is an error wrapping multiple validation
// errors returned by SignalInviteInGroupResp.ValidateAll() if the designated
// constraints aren't met.
type SignalInviteInGroupRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalInviteInGroupRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalInviteInGroupRespMultiError) AllErrors() []error { return m }

// SignalInviteInGroupRespValidationError is the validation error returned by
// SignalInviteInGroupResp.Validate if the designated constraints aren't met.
type SignalInviteInGroupRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalInviteInGroupRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalInviteInGroupRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalInviteInGroupRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalInviteInGroupRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalInviteInGroupRespValidationError) ErrorName() string {
	return "SignalInviteInGroupRespValidationError"
}

// Error satisfies the builtin error interface
func (e SignalInviteInGroupRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalInviteInGroupResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalInviteInGroupRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalInviteInGroupRespValidationError{}

// Validate checks the field values on SignalCancelReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalCancelReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalCancelReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalCancelReqMultiError, or nil if none found.
func (m *SignalCancelReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalCancelReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalCancelReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalCancelReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalCancelReqValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfflinePushInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalCancelReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalCancelReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfflinePushInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalCancelReqValidationError{
				field:  "OfflinePushInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParticipant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalCancelReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalCancelReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParticipant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalCancelReqValidationError{
				field:  "Participant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserID

	if len(errors) > 0 {
		return SignalCancelReqMultiError(errors)
	}

	return nil
}

// SignalCancelReqMultiError is an error wrapping multiple validation errors
// returned by SignalCancelReq.ValidateAll() if the designated constraints
// aren't met.
type SignalCancelReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalCancelReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalCancelReqMultiError) AllErrors() []error { return m }

// SignalCancelReqValidationError is the validation error returned by
// SignalCancelReq.Validate if the designated constraints aren't met.
type SignalCancelReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalCancelReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalCancelReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalCancelReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalCancelReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalCancelReqValidationError) ErrorName() string { return "SignalCancelReqValidationError" }

// Error satisfies the builtin error interface
func (e SignalCancelReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalCancelReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalCancelReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalCancelReqValidationError{}

// Validate checks the field values on SignalCancelResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalCancelResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalCancelResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalCancelRespMultiError, or nil if none found.
func (m *SignalCancelResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalCancelResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SignalCancelRespMultiError(errors)
	}

	return nil
}

// SignalCancelRespMultiError is an error wrapping multiple validation errors
// returned by SignalCancelResp.ValidateAll() if the designated constraints
// aren't met.
type SignalCancelRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalCancelRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalCancelRespMultiError) AllErrors() []error { return m }

// SignalCancelRespValidationError is the validation error returned by
// SignalCancelResp.Validate if the designated constraints aren't met.
type SignalCancelRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalCancelRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalCancelRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalCancelRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalCancelRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalCancelRespValidationError) ErrorName() string { return "SignalCancelRespValidationError" }

// Error satisfies the builtin error interface
func (e SignalCancelRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalCancelResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalCancelRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalCancelRespValidationError{}

// Validate checks the field values on SignalAcceptReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalAcceptReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalAcceptReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalAcceptReqMultiError, or nil if none found.
func (m *SignalAcceptReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalAcceptReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalAcceptReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalAcceptReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalAcceptReqValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfflinePushInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalAcceptReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalAcceptReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfflinePushInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalAcceptReqValidationError{
				field:  "OfflinePushInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParticipant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalAcceptReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalAcceptReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParticipant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalAcceptReqValidationError{
				field:  "Participant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OpUserPlatformID

	// no validation rules for UserID

	if len(errors) > 0 {
		return SignalAcceptReqMultiError(errors)
	}

	return nil
}

// SignalAcceptReqMultiError is an error wrapping multiple validation errors
// returned by SignalAcceptReq.ValidateAll() if the designated constraints
// aren't met.
type SignalAcceptReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalAcceptReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalAcceptReqMultiError) AllErrors() []error { return m }

// SignalAcceptReqValidationError is the validation error returned by
// SignalAcceptReq.Validate if the designated constraints aren't met.
type SignalAcceptReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalAcceptReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalAcceptReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalAcceptReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalAcceptReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalAcceptReqValidationError) ErrorName() string { return "SignalAcceptReqValidationError" }

// Error satisfies the builtin error interface
func (e SignalAcceptReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalAcceptReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalAcceptReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalAcceptReqValidationError{}

// Validate checks the field values on SignalAcceptResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalAcceptResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalAcceptResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalAcceptRespMultiError, or nil if none found.
func (m *SignalAcceptResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalAcceptResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for RoomID

	// no validation rules for LiveURL

	if len(errors) > 0 {
		return SignalAcceptRespMultiError(errors)
	}

	return nil
}

// SignalAcceptRespMultiError is an error wrapping multiple validation errors
// returned by SignalAcceptResp.ValidateAll() if the designated constraints
// aren't met.
type SignalAcceptRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalAcceptRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalAcceptRespMultiError) AllErrors() []error { return m }

// SignalAcceptRespValidationError is the validation error returned by
// SignalAcceptResp.Validate if the designated constraints aren't met.
type SignalAcceptRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalAcceptRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalAcceptRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalAcceptRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalAcceptRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalAcceptRespValidationError) ErrorName() string { return "SignalAcceptRespValidationError" }

// Error satisfies the builtin error interface
func (e SignalAcceptRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalAcceptResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalAcceptRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalAcceptRespValidationError{}

// Validate checks the field values on SignalHungUpReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalHungUpReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalHungUpReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalHungUpReqMultiError, or nil if none found.
func (m *SignalHungUpReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalHungUpReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalHungUpReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalHungUpReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalHungUpReqValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfflinePushInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalHungUpReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalHungUpReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfflinePushInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalHungUpReqValidationError{
				field:  "OfflinePushInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserID

	if len(errors) > 0 {
		return SignalHungUpReqMultiError(errors)
	}

	return nil
}

// SignalHungUpReqMultiError is an error wrapping multiple validation errors
// returned by SignalHungUpReq.ValidateAll() if the designated constraints
// aren't met.
type SignalHungUpReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalHungUpReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalHungUpReqMultiError) AllErrors() []error { return m }

// SignalHungUpReqValidationError is the validation error returned by
// SignalHungUpReq.Validate if the designated constraints aren't met.
type SignalHungUpReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalHungUpReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalHungUpReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalHungUpReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalHungUpReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalHungUpReqValidationError) ErrorName() string { return "SignalHungUpReqValidationError" }

// Error satisfies the builtin error interface
func (e SignalHungUpReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalHungUpReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalHungUpReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalHungUpReqValidationError{}

// Validate checks the field values on SignalHungUpResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalHungUpResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalHungUpResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalHungUpRespMultiError, or nil if none found.
func (m *SignalHungUpResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalHungUpResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SignalHungUpRespMultiError(errors)
	}

	return nil
}

// SignalHungUpRespMultiError is an error wrapping multiple validation errors
// returned by SignalHungUpResp.ValidateAll() if the designated constraints
// aren't met.
type SignalHungUpRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalHungUpRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalHungUpRespMultiError) AllErrors() []error { return m }

// SignalHungUpRespValidationError is the validation error returned by
// SignalHungUpResp.Validate if the designated constraints aren't met.
type SignalHungUpRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalHungUpRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalHungUpRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalHungUpRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalHungUpRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalHungUpRespValidationError) ErrorName() string { return "SignalHungUpRespValidationError" }

// Error satisfies the builtin error interface
func (e SignalHungUpRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalHungUpResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalHungUpRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalHungUpRespValidationError{}

// Validate checks the field values on SignalRejectReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalRejectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalRejectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalRejectReqMultiError, or nil if none found.
func (m *SignalRejectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalRejectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalRejectReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalRejectReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalRejectReqValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfflinePushInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalRejectReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalRejectReqValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfflinePushInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalRejectReqValidationError{
				field:  "OfflinePushInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParticipant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalRejectReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalRejectReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParticipant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalRejectReqValidationError{
				field:  "Participant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OpUserPlatformID

	// no validation rules for UserID

	if len(errors) > 0 {
		return SignalRejectReqMultiError(errors)
	}

	return nil
}

// SignalRejectReqMultiError is an error wrapping multiple validation errors
// returned by SignalRejectReq.ValidateAll() if the designated constraints
// aren't met.
type SignalRejectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalRejectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalRejectReqMultiError) AllErrors() []error { return m }

// SignalRejectReqValidationError is the validation error returned by
// SignalRejectReq.Validate if the designated constraints aren't met.
type SignalRejectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalRejectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalRejectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalRejectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalRejectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalRejectReqValidationError) ErrorName() string { return "SignalRejectReqValidationError" }

// Error satisfies the builtin error interface
func (e SignalRejectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalRejectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalRejectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalRejectReqValidationError{}

// Validate checks the field values on SignalRejectResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalRejectResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalRejectResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalRejectRespMultiError, or nil if none found.
func (m *SignalRejectResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalRejectResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SignalRejectRespMultiError(errors)
	}

	return nil
}

// SignalRejectRespMultiError is an error wrapping multiple validation errors
// returned by SignalRejectResp.ValidateAll() if the designated constraints
// aren't met.
type SignalRejectRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalRejectRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalRejectRespMultiError) AllErrors() []error { return m }

// SignalRejectRespValidationError is the validation error returned by
// SignalRejectResp.Validate if the designated constraints aren't met.
type SignalRejectRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalRejectRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalRejectRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalRejectRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalRejectRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalRejectRespValidationError) ErrorName() string { return "SignalRejectRespValidationError" }

// Error satisfies the builtin error interface
func (e SignalRejectRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalRejectResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalRejectRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalRejectRespValidationError{}

// Validate checks the field values on SignalGetRoomByGroupIDReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalGetRoomByGroupIDReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGetRoomByGroupIDReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalGetRoomByGroupIDReqMultiError, or nil if none found.
func (m *SignalGetRoomByGroupIDReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGetRoomByGroupIDReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GroupID

	if len(errors) > 0 {
		return SignalGetRoomByGroupIDReqMultiError(errors)
	}

	return nil
}

// SignalGetRoomByGroupIDReqMultiError is an error wrapping multiple validation
// errors returned by SignalGetRoomByGroupIDReq.ValidateAll() if the
// designated constraints aren't met.
type SignalGetRoomByGroupIDReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGetRoomByGroupIDReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGetRoomByGroupIDReqMultiError) AllErrors() []error { return m }

// SignalGetRoomByGroupIDReqValidationError is the validation error returned by
// SignalGetRoomByGroupIDReq.Validate if the designated constraints aren't met.
type SignalGetRoomByGroupIDReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGetRoomByGroupIDReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGetRoomByGroupIDReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGetRoomByGroupIDReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGetRoomByGroupIDReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGetRoomByGroupIDReqValidationError) ErrorName() string {
	return "SignalGetRoomByGroupIDReqValidationError"
}

// Error satisfies the builtin error interface
func (e SignalGetRoomByGroupIDReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGetRoomByGroupIDReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGetRoomByGroupIDReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGetRoomByGroupIDReqValidationError{}

// Validate checks the field values on SignalGetRoomByGroupIDResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalGetRoomByGroupIDResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGetRoomByGroupIDResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalGetRoomByGroupIDRespMultiError, or nil if none found.
func (m *SignalGetRoomByGroupIDResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGetRoomByGroupIDResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGetRoomByGroupIDRespValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGetRoomByGroupIDRespValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGetRoomByGroupIDRespValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetParticipant() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalGetRoomByGroupIDRespValidationError{
						field:  fmt.Sprintf("Participant[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalGetRoomByGroupIDRespValidationError{
						field:  fmt.Sprintf("Participant[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalGetRoomByGroupIDRespValidationError{
					field:  fmt.Sprintf("Participant[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RoomID

	if len(errors) > 0 {
		return SignalGetRoomByGroupIDRespMultiError(errors)
	}

	return nil
}

// SignalGetRoomByGroupIDRespMultiError is an error wrapping multiple
// validation errors returned by SignalGetRoomByGroupIDResp.ValidateAll() if
// the designated constraints aren't met.
type SignalGetRoomByGroupIDRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGetRoomByGroupIDRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGetRoomByGroupIDRespMultiError) AllErrors() []error { return m }

// SignalGetRoomByGroupIDRespValidationError is the validation error returned
// by SignalGetRoomByGroupIDResp.Validate if the designated constraints aren't met.
type SignalGetRoomByGroupIDRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGetRoomByGroupIDRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGetRoomByGroupIDRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGetRoomByGroupIDRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGetRoomByGroupIDRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGetRoomByGroupIDRespValidationError) ErrorName() string {
	return "SignalGetRoomByGroupIDRespValidationError"
}

// Error satisfies the builtin error interface
func (e SignalGetRoomByGroupIDRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGetRoomByGroupIDResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGetRoomByGroupIDRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGetRoomByGroupIDRespValidationError{}

// Validate checks the field values on SignalOnRoomParticipantConnectedReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SignalOnRoomParticipantConnectedReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalOnRoomParticipantConnectedReq
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SignalOnRoomParticipantConnectedReqMultiError, or nil if none found.
func (m *SignalOnRoomParticipantConnectedReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalOnRoomParticipantConnectedReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalOnRoomParticipantConnectedReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalOnRoomParticipantConnectedReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalOnRoomParticipantConnectedReqValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetParticipant() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalOnRoomParticipantConnectedReqValidationError{
						field:  fmt.Sprintf("Participant[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalOnRoomParticipantConnectedReqValidationError{
						field:  fmt.Sprintf("Participant[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalOnRoomParticipantConnectedReqValidationError{
					field:  fmt.Sprintf("Participant[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for GroupID

	if len(errors) > 0 {
		return SignalOnRoomParticipantConnectedReqMultiError(errors)
	}

	return nil
}

// SignalOnRoomParticipantConnectedReqMultiError is an error wrapping multiple
// validation errors returned by
// SignalOnRoomParticipantConnectedReq.ValidateAll() if the designated
// constraints aren't met.
type SignalOnRoomParticipantConnectedReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalOnRoomParticipantConnectedReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalOnRoomParticipantConnectedReqMultiError) AllErrors() []error { return m }

// SignalOnRoomParticipantConnectedReqValidationError is the validation error
// returned by SignalOnRoomParticipantConnectedReq.Validate if the designated
// constraints aren't met.
type SignalOnRoomParticipantConnectedReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalOnRoomParticipantConnectedReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalOnRoomParticipantConnectedReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalOnRoomParticipantConnectedReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalOnRoomParticipantConnectedReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalOnRoomParticipantConnectedReqValidationError) ErrorName() string {
	return "SignalOnRoomParticipantConnectedReqValidationError"
}

// Error satisfies the builtin error interface
func (e SignalOnRoomParticipantConnectedReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalOnRoomParticipantConnectedReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalOnRoomParticipantConnectedReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalOnRoomParticipantConnectedReqValidationError{}

// Validate checks the field values on SignalOnRoomParticipantDisconnectedReq
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *SignalOnRoomParticipantDisconnectedReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// SignalOnRoomParticipantDisconnectedReq with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// SignalOnRoomParticipantDisconnectedReqMultiError, or nil if none found.
func (m *SignalOnRoomParticipantDisconnectedReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalOnRoomParticipantDisconnectedReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalOnRoomParticipantDisconnectedReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalOnRoomParticipantDisconnectedReqValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalOnRoomParticipantDisconnectedReqValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetParticipant() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalOnRoomParticipantDisconnectedReqValidationError{
						field:  fmt.Sprintf("Participant[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalOnRoomParticipantDisconnectedReqValidationError{
						field:  fmt.Sprintf("Participant[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalOnRoomParticipantDisconnectedReqValidationError{
					field:  fmt.Sprintf("Participant[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for GroupID

	if len(errors) > 0 {
		return SignalOnRoomParticipantDisconnectedReqMultiError(errors)
	}

	return nil
}

// SignalOnRoomParticipantDisconnectedReqMultiError is an error wrapping
// multiple validation errors returned by
// SignalOnRoomParticipantDisconnectedReq.ValidateAll() if the designated
// constraints aren't met.
type SignalOnRoomParticipantDisconnectedReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalOnRoomParticipantDisconnectedReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalOnRoomParticipantDisconnectedReqMultiError) AllErrors() []error { return m }

// SignalOnRoomParticipantDisconnectedReqValidationError is the validation
// error returned by SignalOnRoomParticipantDisconnectedReq.Validate if the
// designated constraints aren't met.
type SignalOnRoomParticipantDisconnectedReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalOnRoomParticipantDisconnectedReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalOnRoomParticipantDisconnectedReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalOnRoomParticipantDisconnectedReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalOnRoomParticipantDisconnectedReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalOnRoomParticipantDisconnectedReqValidationError) ErrorName() string {
	return "SignalOnRoomParticipantDisconnectedReqValidationError"
}

// Error satisfies the builtin error interface
func (e SignalOnRoomParticipantDisconnectedReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalOnRoomParticipantDisconnectedReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalOnRoomParticipantDisconnectedReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalOnRoomParticipantDisconnectedReqValidationError{}

// Validate checks the field values on SignalGetTokenByRoomIDReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalGetTokenByRoomIDReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGetTokenByRoomIDReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalGetTokenByRoomIDReqMultiError, or nil if none found.
func (m *SignalGetTokenByRoomIDReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGetTokenByRoomIDReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoomID

	if all {
		switch v := interface{}(m.GetParticipant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalGetTokenByRoomIDReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalGetTokenByRoomIDReqValidationError{
					field:  "Participant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParticipant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalGetTokenByRoomIDReqValidationError{
				field:  "Participant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserID

	if len(errors) > 0 {
		return SignalGetTokenByRoomIDReqMultiError(errors)
	}

	return nil
}

// SignalGetTokenByRoomIDReqMultiError is an error wrapping multiple validation
// errors returned by SignalGetTokenByRoomIDReq.ValidateAll() if the
// designated constraints aren't met.
type SignalGetTokenByRoomIDReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGetTokenByRoomIDReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGetTokenByRoomIDReqMultiError) AllErrors() []error { return m }

// SignalGetTokenByRoomIDReqValidationError is the validation error returned by
// SignalGetTokenByRoomIDReq.Validate if the designated constraints aren't met.
type SignalGetTokenByRoomIDReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGetTokenByRoomIDReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGetTokenByRoomIDReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGetTokenByRoomIDReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGetTokenByRoomIDReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGetTokenByRoomIDReqValidationError) ErrorName() string {
	return "SignalGetTokenByRoomIDReqValidationError"
}

// Error satisfies the builtin error interface
func (e SignalGetTokenByRoomIDReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGetTokenByRoomIDReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGetTokenByRoomIDReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGetTokenByRoomIDReqValidationError{}

// Validate checks the field values on SignalGetTokenByRoomIDResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalGetTokenByRoomIDResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGetTokenByRoomIDResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalGetTokenByRoomIDRespMultiError, or nil if none found.
func (m *SignalGetTokenByRoomIDResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGetTokenByRoomIDResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for LiveURL

	if len(errors) > 0 {
		return SignalGetTokenByRoomIDRespMultiError(errors)
	}

	return nil
}

// SignalGetTokenByRoomIDRespMultiError is an error wrapping multiple
// validation errors returned by SignalGetTokenByRoomIDResp.ValidateAll() if
// the designated constraints aren't met.
type SignalGetTokenByRoomIDRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGetTokenByRoomIDRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGetTokenByRoomIDRespMultiError) AllErrors() []error { return m }

// SignalGetTokenByRoomIDRespValidationError is the validation error returned
// by SignalGetTokenByRoomIDResp.Validate if the designated constraints aren't met.
type SignalGetTokenByRoomIDRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGetTokenByRoomIDRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGetTokenByRoomIDRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGetTokenByRoomIDRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGetTokenByRoomIDRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGetTokenByRoomIDRespValidationError) ErrorName() string {
	return "SignalGetTokenByRoomIDRespValidationError"
}

// Error satisfies the builtin error interface
func (e SignalGetTokenByRoomIDRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGetTokenByRoomIDResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGetTokenByRoomIDRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGetTokenByRoomIDRespValidationError{}

// Validate checks the field values on SignalMessageAssembleReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalMessageAssembleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalMessageAssembleReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalMessageAssembleReqMultiError, or nil if none found.
func (m *SignalMessageAssembleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalMessageAssembleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignalReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalMessageAssembleReqValidationError{
					field:  "SignalReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalMessageAssembleReqValidationError{
					field:  "SignalReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignalReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalMessageAssembleReqValidationError{
				field:  "SignalReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignalMessageAssembleReqMultiError(errors)
	}

	return nil
}

// SignalMessageAssembleReqMultiError is an error wrapping multiple validation
// errors returned by SignalMessageAssembleReq.ValidateAll() if the designated
// constraints aren't met.
type SignalMessageAssembleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalMessageAssembleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalMessageAssembleReqMultiError) AllErrors() []error { return m }

// SignalMessageAssembleReqValidationError is the validation error returned by
// SignalMessageAssembleReq.Validate if the designated constraints aren't met.
type SignalMessageAssembleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalMessageAssembleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalMessageAssembleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalMessageAssembleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalMessageAssembleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalMessageAssembleReqValidationError) ErrorName() string {
	return "SignalMessageAssembleReqValidationError"
}

// Error satisfies the builtin error interface
func (e SignalMessageAssembleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalMessageAssembleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalMessageAssembleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalMessageAssembleReqValidationError{}

// Validate checks the field values on SignalMessageAssembleResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalMessageAssembleResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalMessageAssembleResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalMessageAssembleRespMultiError, or nil if none found.
func (m *SignalMessageAssembleResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalMessageAssembleResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignalResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignalMessageAssembleRespValidationError{
					field:  "SignalResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignalMessageAssembleRespValidationError{
					field:  "SignalResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignalResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignalMessageAssembleRespValidationError{
				field:  "SignalResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignalMessageAssembleRespMultiError(errors)
	}

	return nil
}

// SignalMessageAssembleRespMultiError is an error wrapping multiple validation
// errors returned by SignalMessageAssembleResp.ValidateAll() if the
// designated constraints aren't met.
type SignalMessageAssembleRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalMessageAssembleRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalMessageAssembleRespMultiError) AllErrors() []error { return m }

// SignalMessageAssembleRespValidationError is the validation error returned by
// SignalMessageAssembleResp.Validate if the designated constraints aren't met.
type SignalMessageAssembleRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalMessageAssembleRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalMessageAssembleRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalMessageAssembleRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalMessageAssembleRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalMessageAssembleRespValidationError) ErrorName() string {
	return "SignalMessageAssembleRespValidationError"
}

// Error satisfies the builtin error interface
func (e SignalMessageAssembleRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalMessageAssembleResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalMessageAssembleRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalMessageAssembleRespValidationError{}

// Validate checks the field values on SignalGetRoomsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignalGetRoomsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGetRoomsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalGetRoomsReqMultiError, or nil if none found.
func (m *SignalGetRoomsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGetRoomsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SignalGetRoomsReqMultiError(errors)
	}

	return nil
}

// SignalGetRoomsReqMultiError is an error wrapping multiple validation errors
// returned by SignalGetRoomsReq.ValidateAll() if the designated constraints
// aren't met.
type SignalGetRoomsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGetRoomsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGetRoomsReqMultiError) AllErrors() []error { return m }

// SignalGetRoomsReqValidationError is the validation error returned by
// SignalGetRoomsReq.Validate if the designated constraints aren't met.
type SignalGetRoomsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGetRoomsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGetRoomsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGetRoomsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGetRoomsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGetRoomsReqValidationError) ErrorName() string {
	return "SignalGetRoomsReqValidationError"
}

// Error satisfies the builtin error interface
func (e SignalGetRoomsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGetRoomsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGetRoomsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGetRoomsReqValidationError{}

// Validate checks the field values on SignalGetRoomsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignalGetRoomsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalGetRoomsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignalGetRoomsRespMultiError, or nil if none found.
func (m *SignalGetRoomsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalGetRoomsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRoomList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalGetRoomsRespValidationError{
						field:  fmt.Sprintf("RoomList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalGetRoomsRespValidationError{
						field:  fmt.Sprintf("RoomList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalGetRoomsRespValidationError{
					field:  fmt.Sprintf("RoomList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SignalGetRoomsRespMultiError(errors)
	}

	return nil
}

// SignalGetRoomsRespMultiError is an error wrapping multiple validation errors
// returned by SignalGetRoomsResp.ValidateAll() if the designated constraints
// aren't met.
type SignalGetRoomsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalGetRoomsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalGetRoomsRespMultiError) AllErrors() []error { return m }

// SignalGetRoomsRespValidationError is the validation error returned by
// SignalGetRoomsResp.Validate if the designated constraints aren't met.
type SignalGetRoomsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalGetRoomsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalGetRoomsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalGetRoomsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalGetRoomsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalGetRoomsRespValidationError) ErrorName() string {
	return "SignalGetRoomsRespValidationError"
}

// Error satisfies the builtin error interface
func (e SignalGetRoomsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalGetRoomsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalGetRoomsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalGetRoomsRespValidationError{}

// Validate checks the field values on GetSignalInvitationInfoReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSignalInvitationInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSignalInvitationInfoReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSignalInvitationInfoReqMultiError, or nil if none found.
func (m *GetSignalInvitationInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSignalInvitationInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoomID

	if len(errors) > 0 {
		return GetSignalInvitationInfoReqMultiError(errors)
	}

	return nil
}

// GetSignalInvitationInfoReqMultiError is an error wrapping multiple
// validation errors returned by GetSignalInvitationInfoReq.ValidateAll() if
// the designated constraints aren't met.
type GetSignalInvitationInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSignalInvitationInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSignalInvitationInfoReqMultiError) AllErrors() []error { return m }

// GetSignalInvitationInfoReqValidationError is the validation error returned
// by GetSignalInvitationInfoReq.Validate if the designated constraints aren't met.
type GetSignalInvitationInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSignalInvitationInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSignalInvitationInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSignalInvitationInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSignalInvitationInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSignalInvitationInfoReqValidationError) ErrorName() string {
	return "GetSignalInvitationInfoReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetSignalInvitationInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSignalInvitationInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSignalInvitationInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSignalInvitationInfoReqValidationError{}

// Validate checks the field values on GetSignalInvitationInfoResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSignalInvitationInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSignalInvitationInfoResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSignalInvitationInfoRespMultiError, or nil if none found.
func (m *GetSignalInvitationInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSignalInvitationInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitationInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSignalInvitationInfoRespValidationError{
					field:  "InvitationInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSignalInvitationInfoRespValidationError{
					field:  "InvitationInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitationInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSignalInvitationInfoRespValidationError{
				field:  "InvitationInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfflinePushInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSignalInvitationInfoRespValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSignalInvitationInfoRespValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfflinePushInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSignalInvitationInfoRespValidationError{
				field:  "OfflinePushInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSignalInvitationInfoRespMultiError(errors)
	}

	return nil
}

// GetSignalInvitationInfoRespMultiError is an error wrapping multiple
// validation errors returned by GetSignalInvitationInfoResp.ValidateAll() if
// the designated constraints aren't met.
type GetSignalInvitationInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSignalInvitationInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSignalInvitationInfoRespMultiError) AllErrors() []error { return m }

// GetSignalInvitationInfoRespValidationError is the validation error returned
// by GetSignalInvitationInfoResp.Validate if the designated constraints
// aren't met.
type GetSignalInvitationInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSignalInvitationInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSignalInvitationInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSignalInvitationInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSignalInvitationInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSignalInvitationInfoRespValidationError) ErrorName() string {
	return "GetSignalInvitationInfoRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetSignalInvitationInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSignalInvitationInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSignalInvitationInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSignalInvitationInfoRespValidationError{}

// Validate checks the field values on GetSignalInvitationInfoStartAppReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetSignalInvitationInfoStartAppReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSignalInvitationInfoStartAppReq
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetSignalInvitationInfoStartAppReqMultiError, or nil if none found.
func (m *GetSignalInvitationInfoStartAppReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSignalInvitationInfoStartAppReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if len(errors) > 0 {
		return GetSignalInvitationInfoStartAppReqMultiError(errors)
	}

	return nil
}

// GetSignalInvitationInfoStartAppReqMultiError is an error wrapping multiple
// validation errors returned by
// GetSignalInvitationInfoStartAppReq.ValidateAll() if the designated
// constraints aren't met.
type GetSignalInvitationInfoStartAppReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSignalInvitationInfoStartAppReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSignalInvitationInfoStartAppReqMultiError) AllErrors() []error { return m }

// GetSignalInvitationInfoStartAppReqValidationError is the validation error
// returned by GetSignalInvitationInfoStartAppReq.Validate if the designated
// constraints aren't met.
type GetSignalInvitationInfoStartAppReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSignalInvitationInfoStartAppReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSignalInvitationInfoStartAppReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSignalInvitationInfoStartAppReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSignalInvitationInfoStartAppReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSignalInvitationInfoStartAppReqValidationError) ErrorName() string {
	return "GetSignalInvitationInfoStartAppReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetSignalInvitationInfoStartAppReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSignalInvitationInfoStartAppReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSignalInvitationInfoStartAppReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSignalInvitationInfoStartAppReqValidationError{}

// Validate checks the field values on GetSignalInvitationInfoStartAppResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetSignalInvitationInfoStartAppResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSignalInvitationInfoStartAppResp
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetSignalInvitationInfoStartAppRespMultiError, or nil if none found.
func (m *GetSignalInvitationInfoStartAppResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSignalInvitationInfoStartAppResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSignalInvitationInfoStartAppRespValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSignalInvitationInfoStartAppRespValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSignalInvitationInfoStartAppRespValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfflinePushInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSignalInvitationInfoStartAppRespValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSignalInvitationInfoStartAppRespValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfflinePushInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSignalInvitationInfoStartAppRespValidationError{
				field:  "OfflinePushInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSignalInvitationInfoStartAppRespMultiError(errors)
	}

	return nil
}

// GetSignalInvitationInfoStartAppRespMultiError is an error wrapping multiple
// validation errors returned by
// GetSignalInvitationInfoStartAppResp.ValidateAll() if the designated
// constraints aren't met.
type GetSignalInvitationInfoStartAppRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSignalInvitationInfoStartAppRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSignalInvitationInfoStartAppRespMultiError) AllErrors() []error { return m }

// GetSignalInvitationInfoStartAppRespValidationError is the validation error
// returned by GetSignalInvitationInfoStartAppResp.Validate if the designated
// constraints aren't met.
type GetSignalInvitationInfoStartAppRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSignalInvitationInfoStartAppRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSignalInvitationInfoStartAppRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSignalInvitationInfoStartAppRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSignalInvitationInfoStartAppRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSignalInvitationInfoStartAppRespValidationError) ErrorName() string {
	return "GetSignalInvitationInfoStartAppRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetSignalInvitationInfoStartAppRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSignalInvitationInfoStartAppResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSignalInvitationInfoStartAppRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSignalInvitationInfoStartAppRespValidationError{}

// Validate checks the field values on SignalUser with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignalUser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalUser with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignalUserMultiError, or
// nil if none found.
func (m *SignalUser) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalUser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for Nickname

	// no validation rules for Status

	if len(errors) > 0 {
		return SignalUserMultiError(errors)
	}

	return nil
}

// SignalUserMultiError is an error wrapping multiple validation errors
// returned by SignalUser.ValidateAll() if the designated constraints aren't met.
type SignalUserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalUserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalUserMultiError) AllErrors() []error { return m }

// SignalUserValidationError is the validation error returned by
// SignalUser.Validate if the designated constraints aren't met.
type SignalUserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalUserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalUserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalUserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalUserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalUserValidationError) ErrorName() string { return "SignalUserValidationError" }

// Error satisfies the builtin error interface
func (e SignalUserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalUserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalUserValidationError{}

// Validate checks the field values on SignalRecord with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignalRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignalRecord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignalRecordMultiError, or
// nil if none found.
func (m *SignalRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *SignalRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoomID

	// no validation rules for SID

	// no validation rules for FileName

	// no validation rules for MediaType

	// no validation rules for SessionType

	// no validation rules for InviterUserID

	// no validation rules for InviterUserNickname

	// no validation rules for GroupID

	// no validation rules for GroupName

	for idx, item := range m.GetInviterUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignalRecordValidationError{
						field:  fmt.Sprintf("InviterUsers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignalRecordValidationError{
						field:  fmt.Sprintf("InviterUsers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignalRecordValidationError{
					field:  fmt.Sprintf("InviterUsers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CreateTime

	// no validation rules for EndTime

	// no validation rules for Size

	// no validation rules for FileURL

	if len(errors) > 0 {
		return SignalRecordMultiError(errors)
	}

	return nil
}

// SignalRecordMultiError is an error wrapping multiple validation errors
// returned by SignalRecord.ValidateAll() if the designated constraints aren't met.
type SignalRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignalRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignalRecordMultiError) AllErrors() []error { return m }

// SignalRecordValidationError is the validation error returned by
// SignalRecord.Validate if the designated constraints aren't met.
type SignalRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignalRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignalRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignalRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignalRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignalRecordValidationError) ErrorName() string { return "SignalRecordValidationError" }

// Error satisfies the builtin error interface
func (e SignalRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignalRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignalRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignalRecordValidationError{}

// Validate checks the field values on FileRecord with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileRecord with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileRecordMultiError, or
// nil if none found.
func (m *FileRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *FileRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Size

	// no validation rules for FileURL

	if len(errors) > 0 {
		return FileRecordMultiError(errors)
	}

	return nil
}

// FileRecordMultiError is an error wrapping multiple validation errors
// returned by FileRecord.ValidateAll() if the designated constraints aren't met.
type FileRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileRecordMultiError) AllErrors() []error { return m }

// FileRecordValidationError is the validation error returned by
// FileRecord.Validate if the designated constraints aren't met.
type FileRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileRecordValidationError) ErrorName() string { return "FileRecordValidationError" }

// Error satisfies the builtin error interface
func (e FileRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileRecordValidationError{}

// Validate checks the field values on GetSignalInvitationRecordsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSignalInvitationRecordsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSignalInvitationRecordsReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSignalInvitationRecordsReqMultiError, or nil if none found.
func (m *GetSignalInvitationRecordsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSignalInvitationRecordsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSignalInvitationRecordsReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSignalInvitationRecordsReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSignalInvitationRecordsReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SessionType

	// no validation rules for SendID

	// no validation rules for RecvID

	// no validation rules for StartTime

	// no validation rules for EndTime

	for idx, item := range m.GetJoinedUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSignalInvitationRecordsReqValidationError{
						field:  fmt.Sprintf("JoinedUsers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSignalInvitationRecordsReqValidationError{
						field:  fmt.Sprintf("JoinedUsers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSignalInvitationRecordsReqValidationError{
					field:  fmt.Sprintf("JoinedUsers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSignalInvitationRecordsReqMultiError(errors)
	}

	return nil
}

// GetSignalInvitationRecordsReqMultiError is an error wrapping multiple
// validation errors returned by GetSignalInvitationRecordsReq.ValidateAll()
// if the designated constraints aren't met.
type GetSignalInvitationRecordsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSignalInvitationRecordsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSignalInvitationRecordsReqMultiError) AllErrors() []error { return m }

// GetSignalInvitationRecordsReqValidationError is the validation error
// returned by GetSignalInvitationRecordsReq.Validate if the designated
// constraints aren't met.
type GetSignalInvitationRecordsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSignalInvitationRecordsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSignalInvitationRecordsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSignalInvitationRecordsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSignalInvitationRecordsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSignalInvitationRecordsReqValidationError) ErrorName() string {
	return "GetSignalInvitationRecordsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetSignalInvitationRecordsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSignalInvitationRecordsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSignalInvitationRecordsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSignalInvitationRecordsReqValidationError{}

// Validate checks the field values on GetSignalInvitationRecordsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSignalInvitationRecordsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSignalInvitationRecordsResp with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSignalInvitationRecordsRespMultiError, or nil if none found.
func (m *GetSignalInvitationRecordsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSignalInvitationRecordsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetSignalRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSignalInvitationRecordsRespValidationError{
						field:  fmt.Sprintf("SignalRecords[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSignalInvitationRecordsRespValidationError{
						field:  fmt.Sprintf("SignalRecords[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSignalInvitationRecordsRespValidationError{
					field:  fmt.Sprintf("SignalRecords[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSignalInvitationRecordsRespMultiError(errors)
	}

	return nil
}

// GetSignalInvitationRecordsRespMultiError is an error wrapping multiple
// validation errors returned by GetSignalInvitationRecordsResp.ValidateAll()
// if the designated constraints aren't met.
type GetSignalInvitationRecordsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSignalInvitationRecordsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSignalInvitationRecordsRespMultiError) AllErrors() []error { return m }

// GetSignalInvitationRecordsRespValidationError is the validation error
// returned by GetSignalInvitationRecordsResp.Validate if the designated
// constraints aren't met.
type GetSignalInvitationRecordsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSignalInvitationRecordsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSignalInvitationRecordsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSignalInvitationRecordsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSignalInvitationRecordsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSignalInvitationRecordsRespValidationError) ErrorName() string {
	return "GetSignalInvitationRecordsRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetSignalInvitationRecordsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSignalInvitationRecordsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSignalInvitationRecordsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSignalInvitationRecordsRespValidationError{}

// Validate checks the field values on DeleteSignalRecordsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSignalRecordsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSignalRecordsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSignalRecordsReqMultiError, or nil if none found.
func (m *DeleteSignalRecordsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSignalRecordsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteSignalRecordsReqMultiError(errors)
	}

	return nil
}

// DeleteSignalRecordsReqMultiError is an error wrapping multiple validation
// errors returned by DeleteSignalRecordsReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteSignalRecordsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSignalRecordsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSignalRecordsReqMultiError) AllErrors() []error { return m }

// DeleteSignalRecordsReqValidationError is the validation error returned by
// DeleteSignalRecordsReq.Validate if the designated constraints aren't met.
type DeleteSignalRecordsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSignalRecordsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSignalRecordsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSignalRecordsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSignalRecordsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSignalRecordsReqValidationError) ErrorName() string {
	return "DeleteSignalRecordsReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSignalRecordsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSignalRecordsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSignalRecordsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSignalRecordsReqValidationError{}

// Validate checks the field values on DeleteSignalRecordsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSignalRecordsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSignalRecordsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSignalRecordsRespMultiError, or nil if none found.
func (m *DeleteSignalRecordsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSignalRecordsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteSignalRecordsRespMultiError(errors)
	}

	return nil
}

// DeleteSignalRecordsRespMultiError is an error wrapping multiple validation
// errors returned by DeleteSignalRecordsResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteSignalRecordsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSignalRecordsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSignalRecordsRespMultiError) AllErrors() []error { return m }

// DeleteSignalRecordsRespValidationError is the validation error returned by
// DeleteSignalRecordsResp.Validate if the designated constraints aren't met.
type DeleteSignalRecordsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSignalRecordsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSignalRecordsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSignalRecordsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSignalRecordsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSignalRecordsRespValidationError) ErrorName() string {
	return "DeleteSignalRecordsRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSignalRecordsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSignalRecordsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSignalRecordsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSignalRecordsRespValidationError{}
