// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: sdkws/sdkws.proto

package sdkws

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GroupInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GroupInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GroupInfoMultiError, or nil
// if none found.
func (m *GroupInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GroupID

	// no validation rules for GroupName

	// no validation rules for Notification

	// no validation rules for Introduction

	// no validation rules for FaceURL

	// no validation rules for OwnerUserID

	// no validation rules for CreateTime

	// no validation rules for MemberCount

	// no validation rules for Ex

	// no validation rules for Status

	// no validation rules for CreatorUserID

	// no validation rules for GroupType

	// no validation rules for NeedVerification

	// no validation rules for LookMemberInfo

	// no validation rules for ApplyMemberFriend

	// no validation rules for NotificationUpdateTime

	// no validation rules for NotificationUserID

	if len(errors) > 0 {
		return GroupInfoMultiError(errors)
	}

	return nil
}

// GroupInfoMultiError is an error wrapping multiple validation errors returned
// by GroupInfo.ValidateAll() if the designated constraints aren't met.
type GroupInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupInfoMultiError) AllErrors() []error { return m }

// GroupInfoValidationError is the validation error returned by
// GroupInfo.Validate if the designated constraints aren't met.
type GroupInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupInfoValidationError) ErrorName() string { return "GroupInfoValidationError" }

// Error satisfies the builtin error interface
func (e GroupInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupInfoValidationError{}

// Validate checks the field values on GroupInfoForSet with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GroupInfoForSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupInfoForSet with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupInfoForSetMultiError, or nil if none found.
func (m *GroupInfoForSet) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupInfoForSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GroupID

	// no validation rules for GroupName

	// no validation rules for Notification

	// no validation rules for Introduction

	// no validation rules for FaceURL

	if all {
		switch v := interface{}(m.GetEx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupInfoForSetValidationError{
					field:  "Ex",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupInfoForSetValidationError{
					field:  "Ex",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupInfoForSetValidationError{
				field:  "Ex",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNeedVerification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupInfoForSetValidationError{
					field:  "NeedVerification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupInfoForSetValidationError{
					field:  "NeedVerification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNeedVerification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupInfoForSetValidationError{
				field:  "NeedVerification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLookMemberInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupInfoForSetValidationError{
					field:  "LookMemberInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupInfoForSetValidationError{
					field:  "LookMemberInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLookMemberInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupInfoForSetValidationError{
				field:  "LookMemberInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetApplyMemberFriend()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupInfoForSetValidationError{
					field:  "ApplyMemberFriend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupInfoForSetValidationError{
					field:  "ApplyMemberFriend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplyMemberFriend()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupInfoForSetValidationError{
				field:  "ApplyMemberFriend",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GroupInfoForSetMultiError(errors)
	}

	return nil
}

// GroupInfoForSetMultiError is an error wrapping multiple validation errors
// returned by GroupInfoForSet.ValidateAll() if the designated constraints
// aren't met.
type GroupInfoForSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupInfoForSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupInfoForSetMultiError) AllErrors() []error { return m }

// GroupInfoForSetValidationError is the validation error returned by
// GroupInfoForSet.Validate if the designated constraints aren't met.
type GroupInfoForSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupInfoForSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupInfoForSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupInfoForSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupInfoForSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupInfoForSetValidationError) ErrorName() string { return "GroupInfoForSetValidationError" }

// Error satisfies the builtin error interface
func (e GroupInfoForSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupInfoForSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupInfoForSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupInfoForSetValidationError{}

// Validate checks the field values on GroupMemberFullInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupMemberFullInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupMemberFullInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupMemberFullInfoMultiError, or nil if none found.
func (m *GroupMemberFullInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupMemberFullInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GroupID

	// no validation rules for UserID

	// no validation rules for RoleLevel

	// no validation rules for JoinTime

	// no validation rules for Nickname

	// no validation rules for FaceURL

	// no validation rules for AppMangerLevel

	// no validation rules for JoinSource

	// no validation rules for OperatorUserID

	// no validation rules for Ex

	// no validation rules for MuteEndTime

	// no validation rules for InviterUserID

	if len(errors) > 0 {
		return GroupMemberFullInfoMultiError(errors)
	}

	return nil
}

// GroupMemberFullInfoMultiError is an error wrapping multiple validation
// errors returned by GroupMemberFullInfo.ValidateAll() if the designated
// constraints aren't met.
type GroupMemberFullInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupMemberFullInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupMemberFullInfoMultiError) AllErrors() []error { return m }

// GroupMemberFullInfoValidationError is the validation error returned by
// GroupMemberFullInfo.Validate if the designated constraints aren't met.
type GroupMemberFullInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupMemberFullInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupMemberFullInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupMemberFullInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupMemberFullInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupMemberFullInfoValidationError) ErrorName() string {
	return "GroupMemberFullInfoValidationError"
}

// Error satisfies the builtin error interface
func (e GroupMemberFullInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupMemberFullInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupMemberFullInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupMemberFullInfoValidationError{}

// Validate checks the field values on PublicUserInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PublicUserInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PublicUserInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PublicUserInfoMultiError,
// or nil if none found.
func (m *PublicUserInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PublicUserInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for Nickname

	// no validation rules for FaceURL

	// no validation rules for Ex

	if len(errors) > 0 {
		return PublicUserInfoMultiError(errors)
	}

	return nil
}

// PublicUserInfoMultiError is an error wrapping multiple validation errors
// returned by PublicUserInfo.ValidateAll() if the designated constraints
// aren't met.
type PublicUserInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PublicUserInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PublicUserInfoMultiError) AllErrors() []error { return m }

// PublicUserInfoValidationError is the validation error returned by
// PublicUserInfo.Validate if the designated constraints aren't met.
type PublicUserInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PublicUserInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PublicUserInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PublicUserInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PublicUserInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PublicUserInfoValidationError) ErrorName() string { return "PublicUserInfoValidationError" }

// Error satisfies the builtin error interface
func (e PublicUserInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPublicUserInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PublicUserInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PublicUserInfoValidationError{}

// Validate checks the field values on UserInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoMultiError, or nil
// if none found.
func (m *UserInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for Nickname

	// no validation rules for FaceURL

	// no validation rules for Ex

	// no validation rules for CreateTime

	// no validation rules for AppMangerLevel

	// no validation rules for GlobalRecvMsgOpt

	if len(errors) > 0 {
		return UserInfoMultiError(errors)
	}

	return nil
}

// UserInfoMultiError is an error wrapping multiple validation errors returned
// by UserInfo.ValidateAll() if the designated constraints aren't met.
type UserInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoMultiError) AllErrors() []error { return m }

// UserInfoValidationError is the validation error returned by
// UserInfo.Validate if the designated constraints aren't met.
type UserInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoValidationError) ErrorName() string { return "UserInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoValidationError{}

// Validate checks the field values on UserInfoWithEx with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfoWithEx) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfoWithEx with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoWithExMultiError,
// or nil if none found.
func (m *UserInfoWithEx) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfoWithEx) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if all {
		switch v := interface{}(m.GetNickname()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoWithExValidationError{
					field:  "Nickname",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoWithExValidationError{
					field:  "Nickname",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNickname()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoWithExValidationError{
				field:  "Nickname",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFaceURL()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoWithExValidationError{
					field:  "FaceURL",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoWithExValidationError{
					field:  "FaceURL",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFaceURL()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoWithExValidationError{
				field:  "FaceURL",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoWithExValidationError{
					field:  "Ex",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoWithExValidationError{
					field:  "Ex",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoWithExValidationError{
				field:  "Ex",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGlobalRecvMsgOpt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoWithExValidationError{
					field:  "GlobalRecvMsgOpt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoWithExValidationError{
					field:  "GlobalRecvMsgOpt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGlobalRecvMsgOpt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoWithExValidationError{
				field:  "GlobalRecvMsgOpt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserInfoWithExMultiError(errors)
	}

	return nil
}

// UserInfoWithExMultiError is an error wrapping multiple validation errors
// returned by UserInfoWithEx.ValidateAll() if the designated constraints
// aren't met.
type UserInfoWithExMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoWithExMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoWithExMultiError) AllErrors() []error { return m }

// UserInfoWithExValidationError is the validation error returned by
// UserInfoWithEx.Validate if the designated constraints aren't met.
type UserInfoWithExValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoWithExValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoWithExValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoWithExValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoWithExValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoWithExValidationError) ErrorName() string { return "UserInfoWithExValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoWithExValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfoWithEx.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoWithExValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoWithExValidationError{}

// Validate checks the field values on FriendInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FriendInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FriendInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FriendInfoMultiError, or
// nil if none found.
func (m *FriendInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *FriendInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerUserID

	// no validation rules for Remark

	// no validation rules for CreateTime

	if all {
		switch v := interface{}(m.GetFriendUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FriendInfoValidationError{
					field:  "FriendUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FriendInfoValidationError{
					field:  "FriendUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFriendUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FriendInfoValidationError{
				field:  "FriendUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AddSource

	// no validation rules for OperatorUserID

	// no validation rules for Ex

	// no validation rules for IsPinned

	if len(errors) > 0 {
		return FriendInfoMultiError(errors)
	}

	return nil
}

// FriendInfoMultiError is an error wrapping multiple validation errors
// returned by FriendInfo.ValidateAll() if the designated constraints aren't met.
type FriendInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FriendInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FriendInfoMultiError) AllErrors() []error { return m }

// FriendInfoValidationError is the validation error returned by
// FriendInfo.Validate if the designated constraints aren't met.
type FriendInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FriendInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FriendInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FriendInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FriendInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FriendInfoValidationError) ErrorName() string { return "FriendInfoValidationError" }

// Error satisfies the builtin error interface
func (e FriendInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFriendInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FriendInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FriendInfoValidationError{}

// Validate checks the field values on BlackInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlackInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlackInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlackInfoMultiError, or nil
// if none found.
func (m *BlackInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BlackInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerUserID

	// no validation rules for CreateTime

	if all {
		switch v := interface{}(m.GetBlackUserInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlackInfoValidationError{
					field:  "BlackUserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlackInfoValidationError{
					field:  "BlackUserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlackUserInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlackInfoValidationError{
				field:  "BlackUserInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AddSource

	// no validation rules for OperatorUserID

	// no validation rules for Ex

	if len(errors) > 0 {
		return BlackInfoMultiError(errors)
	}

	return nil
}

// BlackInfoMultiError is an error wrapping multiple validation errors returned
// by BlackInfo.ValidateAll() if the designated constraints aren't met.
type BlackInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlackInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlackInfoMultiError) AllErrors() []error { return m }

// BlackInfoValidationError is the validation error returned by
// BlackInfo.Validate if the designated constraints aren't met.
type BlackInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlackInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlackInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlackInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlackInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlackInfoValidationError) ErrorName() string { return "BlackInfoValidationError" }

// Error satisfies the builtin error interface
func (e BlackInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlackInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlackInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlackInfoValidationError{}

// Validate checks the field values on GroupRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GroupRequestMultiError, or
// nil if none found.
func (m *GroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUserInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupRequestValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupRequestValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupRequestValidationError{
				field:  "UserInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroupInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupRequestValidationError{
					field:  "GroupInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupRequestValidationError{
					field:  "GroupInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroupInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupRequestValidationError{
				field:  "GroupInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HandleResult

	// no validation rules for ReqMsg

	// no validation rules for HandleMsg

	// no validation rules for ReqTime

	// no validation rules for HandleUserID

	// no validation rules for HandleTime

	// no validation rules for Ex

	// no validation rules for JoinSource

	// no validation rules for InviterUserID

	if len(errors) > 0 {
		return GroupRequestMultiError(errors)
	}

	return nil
}

// GroupRequestMultiError is an error wrapping multiple validation errors
// returned by GroupRequest.ValidateAll() if the designated constraints aren't met.
type GroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupRequestMultiError) AllErrors() []error { return m }

// GroupRequestValidationError is the validation error returned by
// GroupRequest.Validate if the designated constraints aren't met.
type GroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupRequestValidationError) ErrorName() string { return "GroupRequestValidationError" }

// Error satisfies the builtin error interface
func (e GroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupRequestValidationError{}

// Validate checks the field values on FriendRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FriendRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FriendRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FriendRequestMultiError, or
// nil if none found.
func (m *FriendRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FriendRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FromUserID

	// no validation rules for FromNickname

	// no validation rules for FromFaceURL

	// no validation rules for ToUserID

	// no validation rules for ToNickname

	// no validation rules for ToFaceURL

	// no validation rules for HandleResult

	// no validation rules for ReqMsg

	// no validation rules for CreateTime

	// no validation rules for HandlerUserID

	// no validation rules for HandleMsg

	// no validation rules for HandleTime

	// no validation rules for Ex

	if len(errors) > 0 {
		return FriendRequestMultiError(errors)
	}

	return nil
}

// FriendRequestMultiError is an error wrapping multiple validation errors
// returned by FriendRequest.ValidateAll() if the designated constraints
// aren't met.
type FriendRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FriendRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FriendRequestMultiError) AllErrors() []error { return m }

// FriendRequestValidationError is the validation error returned by
// FriendRequest.Validate if the designated constraints aren't met.
type FriendRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FriendRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FriendRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FriendRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FriendRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FriendRequestValidationError) ErrorName() string { return "FriendRequestValidationError" }

// Error satisfies the builtin error interface
func (e FriendRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFriendRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FriendRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FriendRequestValidationError{}

// Validate checks the field values on PullMessageBySeqsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PullMessageBySeqsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PullMessageBySeqsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PullMessageBySeqsReqMultiError, or nil if none found.
func (m *PullMessageBySeqsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PullMessageBySeqsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	for idx, item := range m.GetSeqRanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PullMessageBySeqsReqValidationError{
						field:  fmt.Sprintf("SeqRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PullMessageBySeqsReqValidationError{
						field:  fmt.Sprintf("SeqRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PullMessageBySeqsReqValidationError{
					field:  fmt.Sprintf("SeqRanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Order

	if len(errors) > 0 {
		return PullMessageBySeqsReqMultiError(errors)
	}

	return nil
}

// PullMessageBySeqsReqMultiError is an error wrapping multiple validation
// errors returned by PullMessageBySeqsReq.ValidateAll() if the designated
// constraints aren't met.
type PullMessageBySeqsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PullMessageBySeqsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PullMessageBySeqsReqMultiError) AllErrors() []error { return m }

// PullMessageBySeqsReqValidationError is the validation error returned by
// PullMessageBySeqsReq.Validate if the designated constraints aren't met.
type PullMessageBySeqsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PullMessageBySeqsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PullMessageBySeqsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PullMessageBySeqsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PullMessageBySeqsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PullMessageBySeqsReqValidationError) ErrorName() string {
	return "PullMessageBySeqsReqValidationError"
}

// Error satisfies the builtin error interface
func (e PullMessageBySeqsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPullMessageBySeqsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PullMessageBySeqsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PullMessageBySeqsReqValidationError{}

// Validate checks the field values on SeqRange with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SeqRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SeqRange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SeqRangeMultiError, or nil
// if none found.
func (m *SeqRange) ValidateAll() error {
	return m.validate(true)
}

func (m *SeqRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConversationID

	// no validation rules for Begin

	// no validation rules for End

	// no validation rules for Num

	if len(errors) > 0 {
		return SeqRangeMultiError(errors)
	}

	return nil
}

// SeqRangeMultiError is an error wrapping multiple validation errors returned
// by SeqRange.ValidateAll() if the designated constraints aren't met.
type SeqRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SeqRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SeqRangeMultiError) AllErrors() []error { return m }

// SeqRangeValidationError is the validation error returned by
// SeqRange.Validate if the designated constraints aren't met.
type SeqRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SeqRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SeqRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SeqRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SeqRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SeqRangeValidationError) ErrorName() string { return "SeqRangeValidationError" }

// Error satisfies the builtin error interface
func (e SeqRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSeqRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SeqRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SeqRangeValidationError{}

// Validate checks the field values on PullMsgs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PullMsgs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PullMsgs with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PullMsgsMultiError, or nil
// if none found.
func (m *PullMsgs) ValidateAll() error {
	return m.validate(true)
}

func (m *PullMsgs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMsgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PullMsgsValidationError{
						field:  fmt.Sprintf("Msgs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PullMsgsValidationError{
						field:  fmt.Sprintf("Msgs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PullMsgsValidationError{
					field:  fmt.Sprintf("Msgs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsEnd

	if len(errors) > 0 {
		return PullMsgsMultiError(errors)
	}

	return nil
}

// PullMsgsMultiError is an error wrapping multiple validation errors returned
// by PullMsgs.ValidateAll() if the designated constraints aren't met.
type PullMsgsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PullMsgsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PullMsgsMultiError) AllErrors() []error { return m }

// PullMsgsValidationError is the validation error returned by
// PullMsgs.Validate if the designated constraints aren't met.
type PullMsgsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PullMsgsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PullMsgsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PullMsgsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PullMsgsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PullMsgsValidationError) ErrorName() string { return "PullMsgsValidationError" }

// Error satisfies the builtin error interface
func (e PullMsgsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPullMsgs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PullMsgsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PullMsgsValidationError{}

// Validate checks the field values on PullMessageBySeqsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PullMessageBySeqsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PullMessageBySeqsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PullMessageBySeqsRespMultiError, or nil if none found.
func (m *PullMessageBySeqsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *PullMessageBySeqsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetMsgs()))
		i := 0
		for key := range m.GetMsgs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMsgs()[key]
			_ = val

			// no validation rules for Msgs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PullMessageBySeqsRespValidationError{
							field:  fmt.Sprintf("Msgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PullMessageBySeqsRespValidationError{
							field:  fmt.Sprintf("Msgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PullMessageBySeqsRespValidationError{
						field:  fmt.Sprintf("Msgs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetNotificationMsgs()))
		i := 0
		for key := range m.GetNotificationMsgs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetNotificationMsgs()[key]
			_ = val

			// no validation rules for NotificationMsgs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PullMessageBySeqsRespValidationError{
							field:  fmt.Sprintf("NotificationMsgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PullMessageBySeqsRespValidationError{
							field:  fmt.Sprintf("NotificationMsgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PullMessageBySeqsRespValidationError{
						field:  fmt.Sprintf("NotificationMsgs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return PullMessageBySeqsRespMultiError(errors)
	}

	return nil
}

// PullMessageBySeqsRespMultiError is an error wrapping multiple validation
// errors returned by PullMessageBySeqsResp.ValidateAll() if the designated
// constraints aren't met.
type PullMessageBySeqsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PullMessageBySeqsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PullMessageBySeqsRespMultiError) AllErrors() []error { return m }

// PullMessageBySeqsRespValidationError is the validation error returned by
// PullMessageBySeqsResp.Validate if the designated constraints aren't met.
type PullMessageBySeqsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PullMessageBySeqsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PullMessageBySeqsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PullMessageBySeqsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PullMessageBySeqsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PullMessageBySeqsRespValidationError) ErrorName() string {
	return "PullMessageBySeqsRespValidationError"
}

// Error satisfies the builtin error interface
func (e PullMessageBySeqsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPullMessageBySeqsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PullMessageBySeqsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PullMessageBySeqsRespValidationError{}

// Validate checks the field values on GetMaxSeqReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMaxSeqReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaxSeqReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMaxSeqReqMultiError, or
// nil if none found.
func (m *GetMaxSeqReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaxSeqReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if len(errors) > 0 {
		return GetMaxSeqReqMultiError(errors)
	}

	return nil
}

// GetMaxSeqReqMultiError is an error wrapping multiple validation errors
// returned by GetMaxSeqReq.ValidateAll() if the designated constraints aren't met.
type GetMaxSeqReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaxSeqReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaxSeqReqMultiError) AllErrors() []error { return m }

// GetMaxSeqReqValidationError is the validation error returned by
// GetMaxSeqReq.Validate if the designated constraints aren't met.
type GetMaxSeqReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaxSeqReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaxSeqReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaxSeqReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaxSeqReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaxSeqReqValidationError) ErrorName() string { return "GetMaxSeqReqValidationError" }

// Error satisfies the builtin error interface
func (e GetMaxSeqReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaxSeqReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaxSeqReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaxSeqReqValidationError{}

// Validate checks the field values on GetMaxSeqResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMaxSeqResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaxSeqResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMaxSeqRespMultiError, or
// nil if none found.
func (m *GetMaxSeqResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaxSeqResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxSeqs

	// no validation rules for MinSeqs

	if len(errors) > 0 {
		return GetMaxSeqRespMultiError(errors)
	}

	return nil
}

// GetMaxSeqRespMultiError is an error wrapping multiple validation errors
// returned by GetMaxSeqResp.ValidateAll() if the designated constraints
// aren't met.
type GetMaxSeqRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaxSeqRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaxSeqRespMultiError) AllErrors() []error { return m }

// GetMaxSeqRespValidationError is the validation error returned by
// GetMaxSeqResp.Validate if the designated constraints aren't met.
type GetMaxSeqRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaxSeqRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaxSeqRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaxSeqRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaxSeqRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaxSeqRespValidationError) ErrorName() string { return "GetMaxSeqRespValidationError" }

// Error satisfies the builtin error interface
func (e GetMaxSeqRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaxSeqResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaxSeqRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaxSeqRespValidationError{}

// Validate checks the field values on UserSendMsgResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserSendMsgResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserSendMsgResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserSendMsgRespMultiError, or nil if none found.
func (m *UserSendMsgResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserSendMsgResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServerMsgID

	// no validation rules for ClientMsgID

	// no validation rules for SendTime

	if len(errors) > 0 {
		return UserSendMsgRespMultiError(errors)
	}

	return nil
}

// UserSendMsgRespMultiError is an error wrapping multiple validation errors
// returned by UserSendMsgResp.ValidateAll() if the designated constraints
// aren't met.
type UserSendMsgRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserSendMsgRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserSendMsgRespMultiError) AllErrors() []error { return m }

// UserSendMsgRespValidationError is the validation error returned by
// UserSendMsgResp.Validate if the designated constraints aren't met.
type UserSendMsgRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSendMsgRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSendMsgRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSendMsgRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSendMsgRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSendMsgRespValidationError) ErrorName() string { return "UserSendMsgRespValidationError" }

// Error satisfies the builtin error interface
func (e UserSendMsgRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSendMsgResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSendMsgRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSendMsgRespValidationError{}

// Validate checks the field values on MsgData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MsgData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgData with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MsgDataMultiError, or nil if none found.
func (m *MsgData) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SendID

	// no validation rules for RecvID

	// no validation rules for GroupID

	// no validation rules for ClientMsgID

	// no validation rules for ServerMsgID

	// no validation rules for SenderPlatformID

	// no validation rules for SenderNickname

	// no validation rules for SenderFaceURL

	// no validation rules for SessionType

	// no validation rules for MsgFrom

	// no validation rules for ContentType

	// no validation rules for Content

	// no validation rules for Seq

	// no validation rules for SendTime

	// no validation rules for CreateTime

	// no validation rules for Status

	// no validation rules for IsRead

	// no validation rules for Options

	if all {
		switch v := interface{}(m.GetOfflinePushInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MsgDataValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MsgDataValidationError{
					field:  "OfflinePushInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfflinePushInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MsgDataValidationError{
				field:  "OfflinePushInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AttachedInfo

	// no validation rules for Ex

	if len(errors) > 0 {
		return MsgDataMultiError(errors)
	}

	return nil
}

// MsgDataMultiError is an error wrapping multiple validation errors returned
// by MsgData.ValidateAll() if the designated constraints aren't met.
type MsgDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgDataMultiError) AllErrors() []error { return m }

// MsgDataValidationError is the validation error returned by MsgData.Validate
// if the designated constraints aren't met.
type MsgDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgDataValidationError) ErrorName() string { return "MsgDataValidationError" }

// Error satisfies the builtin error interface
func (e MsgDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgDataValidationError{}

// Validate checks the field values on PushMessages with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PushMessages) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PushMessages with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PushMessagesMultiError, or
// nil if none found.
func (m *PushMessages) ValidateAll() error {
	return m.validate(true)
}

func (m *PushMessages) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetMsgs()))
		i := 0
		for key := range m.GetMsgs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMsgs()[key]
			_ = val

			// no validation rules for Msgs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PushMessagesValidationError{
							field:  fmt.Sprintf("Msgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PushMessagesValidationError{
							field:  fmt.Sprintf("Msgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PushMessagesValidationError{
						field:  fmt.Sprintf("Msgs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetNotificationMsgs()))
		i := 0
		for key := range m.GetNotificationMsgs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetNotificationMsgs()[key]
			_ = val

			// no validation rules for NotificationMsgs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PushMessagesValidationError{
							field:  fmt.Sprintf("NotificationMsgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PushMessagesValidationError{
							field:  fmt.Sprintf("NotificationMsgs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PushMessagesValidationError{
						field:  fmt.Sprintf("NotificationMsgs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return PushMessagesMultiError(errors)
	}

	return nil
}

// PushMessagesMultiError is an error wrapping multiple validation errors
// returned by PushMessages.ValidateAll() if the designated constraints aren't met.
type PushMessagesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PushMessagesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PushMessagesMultiError) AllErrors() []error { return m }

// PushMessagesValidationError is the validation error returned by
// PushMessages.Validate if the designated constraints aren't met.
type PushMessagesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PushMessagesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PushMessagesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PushMessagesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PushMessagesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PushMessagesValidationError) ErrorName() string { return "PushMessagesValidationError" }

// Error satisfies the builtin error interface
func (e PushMessagesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPushMessages.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PushMessagesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PushMessagesValidationError{}

// Validate checks the field values on OfflinePushInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OfflinePushInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OfflinePushInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OfflinePushInfoMultiError, or nil if none found.
func (m *OfflinePushInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *OfflinePushInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Desc

	// no validation rules for Ex

	// no validation rules for IOSPushSound

	// no validation rules for IOSBadgeCount

	// no validation rules for SignalInfo

	if len(errors) > 0 {
		return OfflinePushInfoMultiError(errors)
	}

	return nil
}

// OfflinePushInfoMultiError is an error wrapping multiple validation errors
// returned by OfflinePushInfo.ValidateAll() if the designated constraints
// aren't met.
type OfflinePushInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OfflinePushInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OfflinePushInfoMultiError) AllErrors() []error { return m }

// OfflinePushInfoValidationError is the validation error returned by
// OfflinePushInfo.Validate if the designated constraints aren't met.
type OfflinePushInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OfflinePushInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OfflinePushInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OfflinePushInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OfflinePushInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OfflinePushInfoValidationError) ErrorName() string { return "OfflinePushInfoValidationError" }

// Error satisfies the builtin error interface
func (e OfflinePushInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOfflinePushInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OfflinePushInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OfflinePushInfoValidationError{}

// Validate checks the field values on TipsComm with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TipsComm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TipsComm with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TipsCommMultiError, or nil
// if none found.
func (m *TipsComm) ValidateAll() error {
	return m.validate(true)
}

func (m *TipsComm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Detail

	// no validation rules for DefaultTips

	// no validation rules for JsonDetail

	if len(errors) > 0 {
		return TipsCommMultiError(errors)
	}

	return nil
}

// TipsCommMultiError is an error wrapping multiple validation errors returned
// by TipsComm.ValidateAll() if the designated constraints aren't met.
type TipsCommMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TipsCommMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TipsCommMultiError) AllErrors() []error { return m }

// TipsCommValidationError is the validation error returned by
// TipsComm.Validate if the designated constraints aren't met.
type TipsCommValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TipsCommValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TipsCommValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TipsCommValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TipsCommValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TipsCommValidationError) ErrorName() string { return "TipsCommValidationError" }

// Error satisfies the builtin error interface
func (e TipsCommValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTipsComm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TipsCommValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TipsCommValidationError{}

// Validate checks the field values on GroupCreatedTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GroupCreatedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupCreatedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupCreatedTipsMultiError, or nil if none found.
func (m *GroupCreatedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupCreatedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupCreatedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupCreatedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupCreatedTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupCreatedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupCreatedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupCreatedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMemberList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GroupCreatedTipsValidationError{
						field:  fmt.Sprintf("MemberList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GroupCreatedTipsValidationError{
						field:  fmt.Sprintf("MemberList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GroupCreatedTipsValidationError{
					field:  fmt.Sprintf("MemberList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for OperationTime

	if all {
		switch v := interface{}(m.GetGroupOwnerUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupCreatedTipsValidationError{
					field:  "GroupOwnerUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupCreatedTipsValidationError{
					field:  "GroupOwnerUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroupOwnerUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupCreatedTipsValidationError{
				field:  "GroupOwnerUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return GroupCreatedTipsMultiError(errors)
	}

	return nil
}

// GroupCreatedTipsMultiError is an error wrapping multiple validation errors
// returned by GroupCreatedTips.ValidateAll() if the designated constraints
// aren't met.
type GroupCreatedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupCreatedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupCreatedTipsMultiError) AllErrors() []error { return m }

// GroupCreatedTipsValidationError is the validation error returned by
// GroupCreatedTips.Validate if the designated constraints aren't met.
type GroupCreatedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupCreatedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupCreatedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupCreatedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupCreatedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupCreatedTipsValidationError) ErrorName() string { return "GroupCreatedTipsValidationError" }

// Error satisfies the builtin error interface
func (e GroupCreatedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupCreatedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupCreatedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupCreatedTipsValidationError{}

// Validate checks the field values on GroupInfoSetTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GroupInfoSetTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupInfoSetTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupInfoSetTipsMultiError, or nil if none found.
func (m *GroupInfoSetTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupInfoSetTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupInfoSetTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupInfoSetTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupInfoSetTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MuteTime

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupInfoSetTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupInfoSetTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupInfoSetTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return GroupInfoSetTipsMultiError(errors)
	}

	return nil
}

// GroupInfoSetTipsMultiError is an error wrapping multiple validation errors
// returned by GroupInfoSetTips.ValidateAll() if the designated constraints
// aren't met.
type GroupInfoSetTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupInfoSetTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupInfoSetTipsMultiError) AllErrors() []error { return m }

// GroupInfoSetTipsValidationError is the validation error returned by
// GroupInfoSetTips.Validate if the designated constraints aren't met.
type GroupInfoSetTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupInfoSetTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupInfoSetTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupInfoSetTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupInfoSetTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupInfoSetTipsValidationError) ErrorName() string { return "GroupInfoSetTipsValidationError" }

// Error satisfies the builtin error interface
func (e GroupInfoSetTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupInfoSetTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupInfoSetTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupInfoSetTipsValidationError{}

// Validate checks the field values on GroupInfoSetNameTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupInfoSetNameTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupInfoSetNameTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupInfoSetNameTipsMultiError, or nil if none found.
func (m *GroupInfoSetNameTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupInfoSetNameTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupInfoSetNameTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupInfoSetNameTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupInfoSetNameTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupInfoSetNameTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupInfoSetNameTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupInfoSetNameTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return GroupInfoSetNameTipsMultiError(errors)
	}

	return nil
}

// GroupInfoSetNameTipsMultiError is an error wrapping multiple validation
// errors returned by GroupInfoSetNameTips.ValidateAll() if the designated
// constraints aren't met.
type GroupInfoSetNameTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupInfoSetNameTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupInfoSetNameTipsMultiError) AllErrors() []error { return m }

// GroupInfoSetNameTipsValidationError is the validation error returned by
// GroupInfoSetNameTips.Validate if the designated constraints aren't met.
type GroupInfoSetNameTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupInfoSetNameTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupInfoSetNameTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupInfoSetNameTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupInfoSetNameTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupInfoSetNameTipsValidationError) ErrorName() string {
	return "GroupInfoSetNameTipsValidationError"
}

// Error satisfies the builtin error interface
func (e GroupInfoSetNameTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupInfoSetNameTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupInfoSetNameTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupInfoSetNameTipsValidationError{}

// Validate checks the field values on GroupInfoSetAnnouncementTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupInfoSetAnnouncementTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupInfoSetAnnouncementTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupInfoSetAnnouncementTipsMultiError, or nil if none found.
func (m *GroupInfoSetAnnouncementTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupInfoSetAnnouncementTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupInfoSetAnnouncementTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupInfoSetAnnouncementTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupInfoSetAnnouncementTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupInfoSetAnnouncementTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupInfoSetAnnouncementTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupInfoSetAnnouncementTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return GroupInfoSetAnnouncementTipsMultiError(errors)
	}

	return nil
}

// GroupInfoSetAnnouncementTipsMultiError is an error wrapping multiple
// validation errors returned by GroupInfoSetAnnouncementTips.ValidateAll() if
// the designated constraints aren't met.
type GroupInfoSetAnnouncementTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupInfoSetAnnouncementTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupInfoSetAnnouncementTipsMultiError) AllErrors() []error { return m }

// GroupInfoSetAnnouncementTipsValidationError is the validation error returned
// by GroupInfoSetAnnouncementTips.Validate if the designated constraints
// aren't met.
type GroupInfoSetAnnouncementTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupInfoSetAnnouncementTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupInfoSetAnnouncementTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupInfoSetAnnouncementTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupInfoSetAnnouncementTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupInfoSetAnnouncementTipsValidationError) ErrorName() string {
	return "GroupInfoSetAnnouncementTipsValidationError"
}

// Error satisfies the builtin error interface
func (e GroupInfoSetAnnouncementTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupInfoSetAnnouncementTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupInfoSetAnnouncementTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupInfoSetAnnouncementTipsValidationError{}

// Validate checks the field values on JoinGroupApplicationTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *JoinGroupApplicationTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JoinGroupApplicationTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// JoinGroupApplicationTipsMultiError, or nil if none found.
func (m *JoinGroupApplicationTips) ValidateAll() error {
	return m.validate(true)
}

func (m *JoinGroupApplicationTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JoinGroupApplicationTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JoinGroupApplicationTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JoinGroupApplicationTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetApplicant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JoinGroupApplicationTipsValidationError{
					field:  "Applicant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JoinGroupApplicationTipsValidationError{
					field:  "Applicant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApplicant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JoinGroupApplicationTipsValidationError{
				field:  "Applicant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReqMsg

	if len(errors) > 0 {
		return JoinGroupApplicationTipsMultiError(errors)
	}

	return nil
}

// JoinGroupApplicationTipsMultiError is an error wrapping multiple validation
// errors returned by JoinGroupApplicationTips.ValidateAll() if the designated
// constraints aren't met.
type JoinGroupApplicationTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JoinGroupApplicationTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JoinGroupApplicationTipsMultiError) AllErrors() []error { return m }

// JoinGroupApplicationTipsValidationError is the validation error returned by
// JoinGroupApplicationTips.Validate if the designated constraints aren't met.
type JoinGroupApplicationTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JoinGroupApplicationTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JoinGroupApplicationTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JoinGroupApplicationTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JoinGroupApplicationTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JoinGroupApplicationTipsValidationError) ErrorName() string {
	return "JoinGroupApplicationTipsValidationError"
}

// Error satisfies the builtin error interface
func (e JoinGroupApplicationTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJoinGroupApplicationTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JoinGroupApplicationTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JoinGroupApplicationTipsValidationError{}

// Validate checks the field values on MemberQuitTips with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MemberQuitTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MemberQuitTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MemberQuitTipsMultiError,
// or nil if none found.
func (m *MemberQuitTips) ValidateAll() error {
	return m.validate(true)
}

func (m *MemberQuitTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberQuitTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberQuitTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberQuitTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQuitUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberQuitTipsValidationError{
					field:  "QuitUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberQuitTipsValidationError{
					field:  "QuitUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuitUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberQuitTipsValidationError{
				field:  "QuitUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OperationTime

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return MemberQuitTipsMultiError(errors)
	}

	return nil
}

// MemberQuitTipsMultiError is an error wrapping multiple validation errors
// returned by MemberQuitTips.ValidateAll() if the designated constraints
// aren't met.
type MemberQuitTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MemberQuitTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MemberQuitTipsMultiError) AllErrors() []error { return m }

// MemberQuitTipsValidationError is the validation error returned by
// MemberQuitTips.Validate if the designated constraints aren't met.
type MemberQuitTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MemberQuitTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MemberQuitTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MemberQuitTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MemberQuitTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MemberQuitTipsValidationError) ErrorName() string { return "MemberQuitTipsValidationError" }

// Error satisfies the builtin error interface
func (e MemberQuitTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMemberQuitTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MemberQuitTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MemberQuitTipsValidationError{}

// Validate checks the field values on GroupApplicationAcceptedTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupApplicationAcceptedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupApplicationAcceptedTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupApplicationAcceptedTipsMultiError, or nil if none found.
func (m *GroupApplicationAcceptedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupApplicationAcceptedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupApplicationAcceptedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupApplicationAcceptedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupApplicationAcceptedTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupApplicationAcceptedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupApplicationAcceptedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupApplicationAcceptedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HandleMsg

	// no validation rules for ReceiverAs

	if len(errors) > 0 {
		return GroupApplicationAcceptedTipsMultiError(errors)
	}

	return nil
}

// GroupApplicationAcceptedTipsMultiError is an error wrapping multiple
// validation errors returned by GroupApplicationAcceptedTips.ValidateAll() if
// the designated constraints aren't met.
type GroupApplicationAcceptedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupApplicationAcceptedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupApplicationAcceptedTipsMultiError) AllErrors() []error { return m }

// GroupApplicationAcceptedTipsValidationError is the validation error returned
// by GroupApplicationAcceptedTips.Validate if the designated constraints
// aren't met.
type GroupApplicationAcceptedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupApplicationAcceptedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupApplicationAcceptedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupApplicationAcceptedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupApplicationAcceptedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupApplicationAcceptedTipsValidationError) ErrorName() string {
	return "GroupApplicationAcceptedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e GroupApplicationAcceptedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupApplicationAcceptedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupApplicationAcceptedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupApplicationAcceptedTipsValidationError{}

// Validate checks the field values on GroupApplicationRejectedTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupApplicationRejectedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupApplicationRejectedTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupApplicationRejectedTipsMultiError, or nil if none found.
func (m *GroupApplicationRejectedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupApplicationRejectedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupApplicationRejectedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupApplicationRejectedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupApplicationRejectedTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupApplicationRejectedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupApplicationRejectedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupApplicationRejectedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HandleMsg

	// no validation rules for ReceiverAs

	if len(errors) > 0 {
		return GroupApplicationRejectedTipsMultiError(errors)
	}

	return nil
}

// GroupApplicationRejectedTipsMultiError is an error wrapping multiple
// validation errors returned by GroupApplicationRejectedTips.ValidateAll() if
// the designated constraints aren't met.
type GroupApplicationRejectedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupApplicationRejectedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupApplicationRejectedTipsMultiError) AllErrors() []error { return m }

// GroupApplicationRejectedTipsValidationError is the validation error returned
// by GroupApplicationRejectedTips.Validate if the designated constraints
// aren't met.
type GroupApplicationRejectedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupApplicationRejectedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupApplicationRejectedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupApplicationRejectedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupApplicationRejectedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupApplicationRejectedTipsValidationError) ErrorName() string {
	return "GroupApplicationRejectedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e GroupApplicationRejectedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupApplicationRejectedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupApplicationRejectedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupApplicationRejectedTipsValidationError{}

// Validate checks the field values on GroupOwnerTransferredTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupOwnerTransferredTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupOwnerTransferredTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupOwnerTransferredTipsMultiError, or nil if none found.
func (m *GroupOwnerTransferredTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupOwnerTransferredTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupOwnerTransferredTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupOwnerTransferredTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupOwnerTransferredTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupOwnerTransferredTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupOwnerTransferredTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupOwnerTransferredTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNewGroupOwner()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupOwnerTransferredTipsValidationError{
					field:  "NewGroupOwner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupOwnerTransferredTipsValidationError{
					field:  "NewGroupOwner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewGroupOwner()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupOwnerTransferredTipsValidationError{
				field:  "NewGroupOwner",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OldGroupOwner

	// no validation rules for OperationTime

	if all {
		switch v := interface{}(m.GetOldGroupOwnerInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupOwnerTransferredTipsValidationError{
					field:  "OldGroupOwnerInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupOwnerTransferredTipsValidationError{
					field:  "OldGroupOwnerInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOldGroupOwnerInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupOwnerTransferredTipsValidationError{
				field:  "OldGroupOwnerInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return GroupOwnerTransferredTipsMultiError(errors)
	}

	return nil
}

// GroupOwnerTransferredTipsMultiError is an error wrapping multiple validation
// errors returned by GroupOwnerTransferredTips.ValidateAll() if the
// designated constraints aren't met.
type GroupOwnerTransferredTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupOwnerTransferredTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupOwnerTransferredTipsMultiError) AllErrors() []error { return m }

// GroupOwnerTransferredTipsValidationError is the validation error returned by
// GroupOwnerTransferredTips.Validate if the designated constraints aren't met.
type GroupOwnerTransferredTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupOwnerTransferredTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupOwnerTransferredTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupOwnerTransferredTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupOwnerTransferredTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupOwnerTransferredTipsValidationError) ErrorName() string {
	return "GroupOwnerTransferredTipsValidationError"
}

// Error satisfies the builtin error interface
func (e GroupOwnerTransferredTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupOwnerTransferredTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupOwnerTransferredTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupOwnerTransferredTipsValidationError{}

// Validate checks the field values on MemberKickedTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MemberKickedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MemberKickedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MemberKickedTipsMultiError, or nil if none found.
func (m *MemberKickedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *MemberKickedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberKickedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberKickedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberKickedTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberKickedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberKickedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberKickedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetKickedUserList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MemberKickedTipsValidationError{
						field:  fmt.Sprintf("KickedUserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MemberKickedTipsValidationError{
						field:  fmt.Sprintf("KickedUserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MemberKickedTipsValidationError{
					field:  fmt.Sprintf("KickedUserList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for OperationTime

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return MemberKickedTipsMultiError(errors)
	}

	return nil
}

// MemberKickedTipsMultiError is an error wrapping multiple validation errors
// returned by MemberKickedTips.ValidateAll() if the designated constraints
// aren't met.
type MemberKickedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MemberKickedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MemberKickedTipsMultiError) AllErrors() []error { return m }

// MemberKickedTipsValidationError is the validation error returned by
// MemberKickedTips.Validate if the designated constraints aren't met.
type MemberKickedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MemberKickedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MemberKickedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MemberKickedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MemberKickedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MemberKickedTipsValidationError) ErrorName() string { return "MemberKickedTipsValidationError" }

// Error satisfies the builtin error interface
func (e MemberKickedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMemberKickedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MemberKickedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MemberKickedTipsValidationError{}

// Validate checks the field values on MemberInvitedTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MemberInvitedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MemberInvitedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MemberInvitedTipsMultiError, or nil if none found.
func (m *MemberInvitedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *MemberInvitedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberInvitedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberInvitedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberInvitedTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberInvitedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberInvitedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberInvitedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInvitedUserList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MemberInvitedTipsValidationError{
						field:  fmt.Sprintf("InvitedUserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MemberInvitedTipsValidationError{
						field:  fmt.Sprintf("InvitedUserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MemberInvitedTipsValidationError{
					field:  fmt.Sprintf("InvitedUserList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for OperationTime

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if all {
		switch v := interface{}(m.GetInviterUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberInvitedTipsValidationError{
					field:  "InviterUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberInvitedTipsValidationError{
					field:  "InviterUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInviterUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberInvitedTipsValidationError{
				field:  "InviterUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MemberInvitedTipsMultiError(errors)
	}

	return nil
}

// MemberInvitedTipsMultiError is an error wrapping multiple validation errors
// returned by MemberInvitedTips.ValidateAll() if the designated constraints
// aren't met.
type MemberInvitedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MemberInvitedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MemberInvitedTipsMultiError) AllErrors() []error { return m }

// MemberInvitedTipsValidationError is the validation error returned by
// MemberInvitedTips.Validate if the designated constraints aren't met.
type MemberInvitedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MemberInvitedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MemberInvitedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MemberInvitedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MemberInvitedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MemberInvitedTipsValidationError) ErrorName() string {
	return "MemberInvitedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e MemberInvitedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMemberInvitedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MemberInvitedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MemberInvitedTipsValidationError{}

// Validate checks the field values on MemberEnterTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MemberEnterTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MemberEnterTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MemberEnterTipsMultiError, or nil if none found.
func (m *MemberEnterTips) ValidateAll() error {
	return m.validate(true)
}

func (m *MemberEnterTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberEnterTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberEnterTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberEnterTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEntrantUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberEnterTipsValidationError{
					field:  "EntrantUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberEnterTipsValidationError{
					field:  "EntrantUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntrantUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberEnterTipsValidationError{
				field:  "EntrantUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OperationTime

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return MemberEnterTipsMultiError(errors)
	}

	return nil
}

// MemberEnterTipsMultiError is an error wrapping multiple validation errors
// returned by MemberEnterTips.ValidateAll() if the designated constraints
// aren't met.
type MemberEnterTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MemberEnterTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MemberEnterTipsMultiError) AllErrors() []error { return m }

// MemberEnterTipsValidationError is the validation error returned by
// MemberEnterTips.Validate if the designated constraints aren't met.
type MemberEnterTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MemberEnterTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MemberEnterTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MemberEnterTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MemberEnterTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MemberEnterTipsValidationError) ErrorName() string { return "MemberEnterTipsValidationError" }

// Error satisfies the builtin error interface
func (e MemberEnterTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMemberEnterTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MemberEnterTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MemberEnterTipsValidationError{}

// Validate checks the field values on GroupDismissedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupDismissedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupDismissedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupDismissedTipsMultiError, or nil if none found.
func (m *GroupDismissedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupDismissedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupDismissedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupDismissedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupDismissedTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupDismissedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupDismissedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupDismissedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OperationTime

	if len(errors) > 0 {
		return GroupDismissedTipsMultiError(errors)
	}

	return nil
}

// GroupDismissedTipsMultiError is an error wrapping multiple validation errors
// returned by GroupDismissedTips.ValidateAll() if the designated constraints
// aren't met.
type GroupDismissedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupDismissedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupDismissedTipsMultiError) AllErrors() []error { return m }

// GroupDismissedTipsValidationError is the validation error returned by
// GroupDismissedTips.Validate if the designated constraints aren't met.
type GroupDismissedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupDismissedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupDismissedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupDismissedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupDismissedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupDismissedTipsValidationError) ErrorName() string {
	return "GroupDismissedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e GroupDismissedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupDismissedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupDismissedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupDismissedTipsValidationError{}

// Validate checks the field values on GroupMemberMutedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupMemberMutedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupMemberMutedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupMemberMutedTipsMultiError, or nil if none found.
func (m *GroupMemberMutedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupMemberMutedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMemberMutedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMemberMutedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMemberMutedTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMemberMutedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMemberMutedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMemberMutedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OperationTime

	if all {
		switch v := interface{}(m.GetMutedUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMemberMutedTipsValidationError{
					field:  "MutedUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMemberMutedTipsValidationError{
					field:  "MutedUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMutedUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMemberMutedTipsValidationError{
				field:  "MutedUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MutedSeconds

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return GroupMemberMutedTipsMultiError(errors)
	}

	return nil
}

// GroupMemberMutedTipsMultiError is an error wrapping multiple validation
// errors returned by GroupMemberMutedTips.ValidateAll() if the designated
// constraints aren't met.
type GroupMemberMutedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupMemberMutedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupMemberMutedTipsMultiError) AllErrors() []error { return m }

// GroupMemberMutedTipsValidationError is the validation error returned by
// GroupMemberMutedTips.Validate if the designated constraints aren't met.
type GroupMemberMutedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupMemberMutedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupMemberMutedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupMemberMutedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupMemberMutedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupMemberMutedTipsValidationError) ErrorName() string {
	return "GroupMemberMutedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e GroupMemberMutedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupMemberMutedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupMemberMutedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupMemberMutedTipsValidationError{}

// Validate checks the field values on GroupMemberCancelMutedTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupMemberCancelMutedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupMemberCancelMutedTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupMemberCancelMutedTipsMultiError, or nil if none found.
func (m *GroupMemberCancelMutedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupMemberCancelMutedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMemberCancelMutedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMemberCancelMutedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMemberCancelMutedTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMemberCancelMutedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMemberCancelMutedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMemberCancelMutedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OperationTime

	if all {
		switch v := interface{}(m.GetMutedUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMemberCancelMutedTipsValidationError{
					field:  "MutedUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMemberCancelMutedTipsValidationError{
					field:  "MutedUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMutedUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMemberCancelMutedTipsValidationError{
				field:  "MutedUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return GroupMemberCancelMutedTipsMultiError(errors)
	}

	return nil
}

// GroupMemberCancelMutedTipsMultiError is an error wrapping multiple
// validation errors returned by GroupMemberCancelMutedTips.ValidateAll() if
// the designated constraints aren't met.
type GroupMemberCancelMutedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupMemberCancelMutedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupMemberCancelMutedTipsMultiError) AllErrors() []error { return m }

// GroupMemberCancelMutedTipsValidationError is the validation error returned
// by GroupMemberCancelMutedTips.Validate if the designated constraints aren't met.
type GroupMemberCancelMutedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupMemberCancelMutedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupMemberCancelMutedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupMemberCancelMutedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupMemberCancelMutedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupMemberCancelMutedTipsValidationError) ErrorName() string {
	return "GroupMemberCancelMutedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e GroupMemberCancelMutedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupMemberCancelMutedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupMemberCancelMutedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupMemberCancelMutedTipsValidationError{}

// Validate checks the field values on GroupMutedTips with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GroupMutedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupMutedTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GroupMutedTipsMultiError,
// or nil if none found.
func (m *GroupMutedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupMutedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMutedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMutedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMutedTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMutedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMutedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMutedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OperationTime

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return GroupMutedTipsMultiError(errors)
	}

	return nil
}

// GroupMutedTipsMultiError is an error wrapping multiple validation errors
// returned by GroupMutedTips.ValidateAll() if the designated constraints
// aren't met.
type GroupMutedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupMutedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupMutedTipsMultiError) AllErrors() []error { return m }

// GroupMutedTipsValidationError is the validation error returned by
// GroupMutedTips.Validate if the designated constraints aren't met.
type GroupMutedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupMutedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupMutedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupMutedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupMutedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupMutedTipsValidationError) ErrorName() string { return "GroupMutedTipsValidationError" }

// Error satisfies the builtin error interface
func (e GroupMutedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupMutedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupMutedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupMutedTipsValidationError{}

// Validate checks the field values on GroupCancelMutedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupCancelMutedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupCancelMutedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupCancelMutedTipsMultiError, or nil if none found.
func (m *GroupCancelMutedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupCancelMutedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupCancelMutedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupCancelMutedTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupCancelMutedTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupCancelMutedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupCancelMutedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupCancelMutedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OperationTime

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	if len(errors) > 0 {
		return GroupCancelMutedTipsMultiError(errors)
	}

	return nil
}

// GroupCancelMutedTipsMultiError is an error wrapping multiple validation
// errors returned by GroupCancelMutedTips.ValidateAll() if the designated
// constraints aren't met.
type GroupCancelMutedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupCancelMutedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupCancelMutedTipsMultiError) AllErrors() []error { return m }

// GroupCancelMutedTipsValidationError is the validation error returned by
// GroupCancelMutedTips.Validate if the designated constraints aren't met.
type GroupCancelMutedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupCancelMutedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupCancelMutedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupCancelMutedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupCancelMutedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupCancelMutedTipsValidationError) ErrorName() string {
	return "GroupCancelMutedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e GroupCancelMutedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupCancelMutedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupCancelMutedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupCancelMutedTipsValidationError{}

// Validate checks the field values on GroupMemberInfoSetTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GroupMemberInfoSetTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupMemberInfoSetTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupMemberInfoSetTipsMultiError, or nil if none found.
func (m *GroupMemberInfoSetTips) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupMemberInfoSetTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMemberInfoSetTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMemberInfoSetTipsValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMemberInfoSetTipsValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMemberInfoSetTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMemberInfoSetTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMemberInfoSetTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OperationTime

	if all {
		switch v := interface{}(m.GetChangedUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupMemberInfoSetTipsValidationError{
					field:  "ChangedUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupMemberInfoSetTipsValidationError{
					field:  "ChangedUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChangedUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupMemberInfoSetTipsValidationError{
				field:  "ChangedUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GroupMemberVersion

	// no validation rules for GroupMemberVersionID

	// no validation rules for GroupSortVersion

	if len(errors) > 0 {
		return GroupMemberInfoSetTipsMultiError(errors)
	}

	return nil
}

// GroupMemberInfoSetTipsMultiError is an error wrapping multiple validation
// errors returned by GroupMemberInfoSetTips.ValidateAll() if the designated
// constraints aren't met.
type GroupMemberInfoSetTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupMemberInfoSetTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupMemberInfoSetTipsMultiError) AllErrors() []error { return m }

// GroupMemberInfoSetTipsValidationError is the validation error returned by
// GroupMemberInfoSetTips.Validate if the designated constraints aren't met.
type GroupMemberInfoSetTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupMemberInfoSetTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupMemberInfoSetTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupMemberInfoSetTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupMemberInfoSetTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupMemberInfoSetTipsValidationError) ErrorName() string {
	return "GroupMemberInfoSetTipsValidationError"
}

// Error satisfies the builtin error interface
func (e GroupMemberInfoSetTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupMemberInfoSetTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupMemberInfoSetTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupMemberInfoSetTipsValidationError{}

// Validate checks the field values on FriendApplication with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FriendApplication) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FriendApplication with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FriendApplicationMultiError, or nil if none found.
func (m *FriendApplication) ValidateAll() error {
	return m.validate(true)
}

func (m *FriendApplication) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddTime

	// no validation rules for AddSource

	// no validation rules for AddWording

	if len(errors) > 0 {
		return FriendApplicationMultiError(errors)
	}

	return nil
}

// FriendApplicationMultiError is an error wrapping multiple validation errors
// returned by FriendApplication.ValidateAll() if the designated constraints
// aren't met.
type FriendApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FriendApplicationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FriendApplicationMultiError) AllErrors() []error { return m }

// FriendApplicationValidationError is the validation error returned by
// FriendApplication.Validate if the designated constraints aren't met.
type FriendApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FriendApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FriendApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FriendApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FriendApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FriendApplicationValidationError) ErrorName() string {
	return "FriendApplicationValidationError"
}

// Error satisfies the builtin error interface
func (e FriendApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFriendApplication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FriendApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FriendApplicationValidationError{}

// Validate checks the field values on FromToUserID with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FromToUserID) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FromToUserID with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FromToUserIDMultiError, or
// nil if none found.
func (m *FromToUserID) ValidateAll() error {
	return m.validate(true)
}

func (m *FromToUserID) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FromUserID

	// no validation rules for ToUserID

	if len(errors) > 0 {
		return FromToUserIDMultiError(errors)
	}

	return nil
}

// FromToUserIDMultiError is an error wrapping multiple validation errors
// returned by FromToUserID.ValidateAll() if the designated constraints aren't met.
type FromToUserIDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FromToUserIDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FromToUserIDMultiError) AllErrors() []error { return m }

// FromToUserIDValidationError is the validation error returned by
// FromToUserID.Validate if the designated constraints aren't met.
type FromToUserIDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FromToUserIDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FromToUserIDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FromToUserIDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FromToUserIDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FromToUserIDValidationError) ErrorName() string { return "FromToUserIDValidationError" }

// Error satisfies the builtin error interface
func (e FromToUserIDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFromToUserID.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FromToUserIDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FromToUserIDValidationError{}

// Validate checks the field values on FriendApplicationTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FriendApplicationTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FriendApplicationTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FriendApplicationTipsMultiError, or nil if none found.
func (m *FriendApplicationTips) ValidateAll() error {
	return m.validate(true)
}

func (m *FriendApplicationTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFromToUserID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FriendApplicationTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FriendApplicationTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFromToUserID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FriendApplicationTipsValidationError{
				field:  "FromToUserID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FriendApplicationTipsMultiError(errors)
	}

	return nil
}

// FriendApplicationTipsMultiError is an error wrapping multiple validation
// errors returned by FriendApplicationTips.ValidateAll() if the designated
// constraints aren't met.
type FriendApplicationTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FriendApplicationTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FriendApplicationTipsMultiError) AllErrors() []error { return m }

// FriendApplicationTipsValidationError is the validation error returned by
// FriendApplicationTips.Validate if the designated constraints aren't met.
type FriendApplicationTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FriendApplicationTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FriendApplicationTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FriendApplicationTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FriendApplicationTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FriendApplicationTipsValidationError) ErrorName() string {
	return "FriendApplicationTipsValidationError"
}

// Error satisfies the builtin error interface
func (e FriendApplicationTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFriendApplicationTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FriendApplicationTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FriendApplicationTipsValidationError{}

// Validate checks the field values on FriendApplicationApprovedTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FriendApplicationApprovedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FriendApplicationApprovedTips with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FriendApplicationApprovedTipsMultiError, or nil if none found.
func (m *FriendApplicationApprovedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *FriendApplicationApprovedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFromToUserID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FriendApplicationApprovedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FriendApplicationApprovedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFromToUserID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FriendApplicationApprovedTipsValidationError{
				field:  "FromToUserID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HandleMsg

	// no validation rules for FriendVersion

	// no validation rules for FriendVersionID

	if len(errors) > 0 {
		return FriendApplicationApprovedTipsMultiError(errors)
	}

	return nil
}

// FriendApplicationApprovedTipsMultiError is an error wrapping multiple
// validation errors returned by FriendApplicationApprovedTips.ValidateAll()
// if the designated constraints aren't met.
type FriendApplicationApprovedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FriendApplicationApprovedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FriendApplicationApprovedTipsMultiError) AllErrors() []error { return m }

// FriendApplicationApprovedTipsValidationError is the validation error
// returned by FriendApplicationApprovedTips.Validate if the designated
// constraints aren't met.
type FriendApplicationApprovedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FriendApplicationApprovedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FriendApplicationApprovedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FriendApplicationApprovedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FriendApplicationApprovedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FriendApplicationApprovedTipsValidationError) ErrorName() string {
	return "FriendApplicationApprovedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e FriendApplicationApprovedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFriendApplicationApprovedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FriendApplicationApprovedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FriendApplicationApprovedTipsValidationError{}

// Validate checks the field values on FriendApplicationRejectedTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FriendApplicationRejectedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FriendApplicationRejectedTips with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FriendApplicationRejectedTipsMultiError, or nil if none found.
func (m *FriendApplicationRejectedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *FriendApplicationRejectedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFromToUserID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FriendApplicationRejectedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FriendApplicationRejectedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFromToUserID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FriendApplicationRejectedTipsValidationError{
				field:  "FromToUserID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HandleMsg

	if len(errors) > 0 {
		return FriendApplicationRejectedTipsMultiError(errors)
	}

	return nil
}

// FriendApplicationRejectedTipsMultiError is an error wrapping multiple
// validation errors returned by FriendApplicationRejectedTips.ValidateAll()
// if the designated constraints aren't met.
type FriendApplicationRejectedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FriendApplicationRejectedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FriendApplicationRejectedTipsMultiError) AllErrors() []error { return m }

// FriendApplicationRejectedTipsValidationError is the validation error
// returned by FriendApplicationRejectedTips.Validate if the designated
// constraints aren't met.
type FriendApplicationRejectedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FriendApplicationRejectedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FriendApplicationRejectedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FriendApplicationRejectedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FriendApplicationRejectedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FriendApplicationRejectedTipsValidationError) ErrorName() string {
	return "FriendApplicationRejectedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e FriendApplicationRejectedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFriendApplicationRejectedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FriendApplicationRejectedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FriendApplicationRejectedTipsValidationError{}

// Validate checks the field values on FriendAddedTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FriendAddedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FriendAddedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FriendAddedTipsMultiError, or nil if none found.
func (m *FriendAddedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *FriendAddedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFriend()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FriendAddedTipsValidationError{
					field:  "Friend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FriendAddedTipsValidationError{
					field:  "Friend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFriend()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FriendAddedTipsValidationError{
				field:  "Friend",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OperationTime

	if all {
		switch v := interface{}(m.GetOpUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FriendAddedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FriendAddedTipsValidationError{
					field:  "OpUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FriendAddedTipsValidationError{
				field:  "OpUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FriendVersion

	// no validation rules for FriendVersionID

	if len(errors) > 0 {
		return FriendAddedTipsMultiError(errors)
	}

	return nil
}

// FriendAddedTipsMultiError is an error wrapping multiple validation errors
// returned by FriendAddedTips.ValidateAll() if the designated constraints
// aren't met.
type FriendAddedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FriendAddedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FriendAddedTipsMultiError) AllErrors() []error { return m }

// FriendAddedTipsValidationError is the validation error returned by
// FriendAddedTips.Validate if the designated constraints aren't met.
type FriendAddedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FriendAddedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FriendAddedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FriendAddedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FriendAddedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FriendAddedTipsValidationError) ErrorName() string { return "FriendAddedTipsValidationError" }

// Error satisfies the builtin error interface
func (e FriendAddedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFriendAddedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FriendAddedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FriendAddedTipsValidationError{}

// Validate checks the field values on FriendDeletedTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FriendDeletedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FriendDeletedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FriendDeletedTipsMultiError, or nil if none found.
func (m *FriendDeletedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *FriendDeletedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFromToUserID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FriendDeletedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FriendDeletedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFromToUserID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FriendDeletedTipsValidationError{
				field:  "FromToUserID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FriendVersion

	// no validation rules for FriendVersionID

	if len(errors) > 0 {
		return FriendDeletedTipsMultiError(errors)
	}

	return nil
}

// FriendDeletedTipsMultiError is an error wrapping multiple validation errors
// returned by FriendDeletedTips.ValidateAll() if the designated constraints
// aren't met.
type FriendDeletedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FriendDeletedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FriendDeletedTipsMultiError) AllErrors() []error { return m }

// FriendDeletedTipsValidationError is the validation error returned by
// FriendDeletedTips.Validate if the designated constraints aren't met.
type FriendDeletedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FriendDeletedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FriendDeletedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FriendDeletedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FriendDeletedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FriendDeletedTipsValidationError) ErrorName() string {
	return "FriendDeletedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e FriendDeletedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFriendDeletedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FriendDeletedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FriendDeletedTipsValidationError{}

// Validate checks the field values on BlackAddedTips with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlackAddedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlackAddedTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlackAddedTipsMultiError,
// or nil if none found.
func (m *BlackAddedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *BlackAddedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFromToUserID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlackAddedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlackAddedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFromToUserID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlackAddedTipsValidationError{
				field:  "FromToUserID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BlackAddedTipsMultiError(errors)
	}

	return nil
}

// BlackAddedTipsMultiError is an error wrapping multiple validation errors
// returned by BlackAddedTips.ValidateAll() if the designated constraints
// aren't met.
type BlackAddedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlackAddedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlackAddedTipsMultiError) AllErrors() []error { return m }

// BlackAddedTipsValidationError is the validation error returned by
// BlackAddedTips.Validate if the designated constraints aren't met.
type BlackAddedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlackAddedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlackAddedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlackAddedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlackAddedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlackAddedTipsValidationError) ErrorName() string { return "BlackAddedTipsValidationError" }

// Error satisfies the builtin error interface
func (e BlackAddedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlackAddedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlackAddedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlackAddedTipsValidationError{}

// Validate checks the field values on BlackDeletedTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BlackDeletedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlackDeletedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlackDeletedTipsMultiError, or nil if none found.
func (m *BlackDeletedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *BlackDeletedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFromToUserID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlackDeletedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlackDeletedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFromToUserID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlackDeletedTipsValidationError{
				field:  "FromToUserID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BlackDeletedTipsMultiError(errors)
	}

	return nil
}

// BlackDeletedTipsMultiError is an error wrapping multiple validation errors
// returned by BlackDeletedTips.ValidateAll() if the designated constraints
// aren't met.
type BlackDeletedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlackDeletedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlackDeletedTipsMultiError) AllErrors() []error { return m }

// BlackDeletedTipsValidationError is the validation error returned by
// BlackDeletedTips.Validate if the designated constraints aren't met.
type BlackDeletedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlackDeletedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlackDeletedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlackDeletedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlackDeletedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlackDeletedTipsValidationError) ErrorName() string { return "BlackDeletedTipsValidationError" }

// Error satisfies the builtin error interface
func (e BlackDeletedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlackDeletedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlackDeletedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlackDeletedTipsValidationError{}

// Validate checks the field values on FriendInfoChangedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FriendInfoChangedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FriendInfoChangedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FriendInfoChangedTipsMultiError, or nil if none found.
func (m *FriendInfoChangedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *FriendInfoChangedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFromToUserID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FriendInfoChangedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FriendInfoChangedTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFromToUserID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FriendInfoChangedTipsValidationError{
				field:  "FromToUserID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FriendVersion

	// no validation rules for FriendVersionID

	// no validation rules for FriendSortVersion

	if len(errors) > 0 {
		return FriendInfoChangedTipsMultiError(errors)
	}

	return nil
}

// FriendInfoChangedTipsMultiError is an error wrapping multiple validation
// errors returned by FriendInfoChangedTips.ValidateAll() if the designated
// constraints aren't met.
type FriendInfoChangedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FriendInfoChangedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FriendInfoChangedTipsMultiError) AllErrors() []error { return m }

// FriendInfoChangedTipsValidationError is the validation error returned by
// FriendInfoChangedTips.Validate if the designated constraints aren't met.
type FriendInfoChangedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FriendInfoChangedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FriendInfoChangedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FriendInfoChangedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FriendInfoChangedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FriendInfoChangedTipsValidationError) ErrorName() string {
	return "FriendInfoChangedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e FriendInfoChangedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFriendInfoChangedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FriendInfoChangedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FriendInfoChangedTipsValidationError{}

// Validate checks the field values on UserInfoUpdatedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInfoUpdatedTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfoUpdatedTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInfoUpdatedTipsMultiError, or nil if none found.
func (m *UserInfoUpdatedTips) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfoUpdatedTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if len(errors) > 0 {
		return UserInfoUpdatedTipsMultiError(errors)
	}

	return nil
}

// UserInfoUpdatedTipsMultiError is an error wrapping multiple validation
// errors returned by UserInfoUpdatedTips.ValidateAll() if the designated
// constraints aren't met.
type UserInfoUpdatedTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoUpdatedTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoUpdatedTipsMultiError) AllErrors() []error { return m }

// UserInfoUpdatedTipsValidationError is the validation error returned by
// UserInfoUpdatedTips.Validate if the designated constraints aren't met.
type UserInfoUpdatedTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoUpdatedTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoUpdatedTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoUpdatedTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoUpdatedTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoUpdatedTipsValidationError) ErrorName() string {
	return "UserInfoUpdatedTipsValidationError"
}

// Error satisfies the builtin error interface
func (e UserInfoUpdatedTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfoUpdatedTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoUpdatedTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoUpdatedTipsValidationError{}

// Validate checks the field values on UserStatusChangeTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserStatusChangeTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserStatusChangeTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserStatusChangeTipsMultiError, or nil if none found.
func (m *UserStatusChangeTips) ValidateAll() error {
	return m.validate(true)
}

func (m *UserStatusChangeTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FromUserID

	// no validation rules for ToUserID

	// no validation rules for Status

	// no validation rules for PlatformID

	if len(errors) > 0 {
		return UserStatusChangeTipsMultiError(errors)
	}

	return nil
}

// UserStatusChangeTipsMultiError is an error wrapping multiple validation
// errors returned by UserStatusChangeTips.ValidateAll() if the designated
// constraints aren't met.
type UserStatusChangeTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserStatusChangeTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserStatusChangeTipsMultiError) AllErrors() []error { return m }

// UserStatusChangeTipsValidationError is the validation error returned by
// UserStatusChangeTips.Validate if the designated constraints aren't met.
type UserStatusChangeTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserStatusChangeTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserStatusChangeTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserStatusChangeTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserStatusChangeTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserStatusChangeTipsValidationError) ErrorName() string {
	return "UserStatusChangeTipsValidationError"
}

// Error satisfies the builtin error interface
func (e UserStatusChangeTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserStatusChangeTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserStatusChangeTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserStatusChangeTipsValidationError{}

// Validate checks the field values on UserCommandAddTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCommandAddTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCommandAddTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCommandAddTipsMultiError, or nil if none found.
func (m *UserCommandAddTips) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCommandAddTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FromUserID

	// no validation rules for ToUserID

	if len(errors) > 0 {
		return UserCommandAddTipsMultiError(errors)
	}

	return nil
}

// UserCommandAddTipsMultiError is an error wrapping multiple validation errors
// returned by UserCommandAddTips.ValidateAll() if the designated constraints
// aren't met.
type UserCommandAddTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCommandAddTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCommandAddTipsMultiError) AllErrors() []error { return m }

// UserCommandAddTipsValidationError is the validation error returned by
// UserCommandAddTips.Validate if the designated constraints aren't met.
type UserCommandAddTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCommandAddTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCommandAddTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCommandAddTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCommandAddTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCommandAddTipsValidationError) ErrorName() string {
	return "UserCommandAddTipsValidationError"
}

// Error satisfies the builtin error interface
func (e UserCommandAddTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCommandAddTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCommandAddTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCommandAddTipsValidationError{}

// Validate checks the field values on UserCommandUpdateTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCommandUpdateTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCommandUpdateTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCommandUpdateTipsMultiError, or nil if none found.
func (m *UserCommandUpdateTips) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCommandUpdateTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FromUserID

	// no validation rules for ToUserID

	if len(errors) > 0 {
		return UserCommandUpdateTipsMultiError(errors)
	}

	return nil
}

// UserCommandUpdateTipsMultiError is an error wrapping multiple validation
// errors returned by UserCommandUpdateTips.ValidateAll() if the designated
// constraints aren't met.
type UserCommandUpdateTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCommandUpdateTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCommandUpdateTipsMultiError) AllErrors() []error { return m }

// UserCommandUpdateTipsValidationError is the validation error returned by
// UserCommandUpdateTips.Validate if the designated constraints aren't met.
type UserCommandUpdateTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCommandUpdateTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCommandUpdateTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCommandUpdateTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCommandUpdateTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCommandUpdateTipsValidationError) ErrorName() string {
	return "UserCommandUpdateTipsValidationError"
}

// Error satisfies the builtin error interface
func (e UserCommandUpdateTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCommandUpdateTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCommandUpdateTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCommandUpdateTipsValidationError{}

// Validate checks the field values on UserCommandDeleteTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserCommandDeleteTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserCommandDeleteTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserCommandDeleteTipsMultiError, or nil if none found.
func (m *UserCommandDeleteTips) ValidateAll() error {
	return m.validate(true)
}

func (m *UserCommandDeleteTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FromUserID

	// no validation rules for ToUserID

	if len(errors) > 0 {
		return UserCommandDeleteTipsMultiError(errors)
	}

	return nil
}

// UserCommandDeleteTipsMultiError is an error wrapping multiple validation
// errors returned by UserCommandDeleteTips.ValidateAll() if the designated
// constraints aren't met.
type UserCommandDeleteTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserCommandDeleteTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserCommandDeleteTipsMultiError) AllErrors() []error { return m }

// UserCommandDeleteTipsValidationError is the validation error returned by
// UserCommandDeleteTips.Validate if the designated constraints aren't met.
type UserCommandDeleteTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserCommandDeleteTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserCommandDeleteTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserCommandDeleteTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserCommandDeleteTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserCommandDeleteTipsValidationError) ErrorName() string {
	return "UserCommandDeleteTipsValidationError"
}

// Error satisfies the builtin error interface
func (e UserCommandDeleteTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserCommandDeleteTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserCommandDeleteTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserCommandDeleteTipsValidationError{}

// Validate checks the field values on ConversationUpdateTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConversationUpdateTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConversationUpdateTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConversationUpdateTipsMultiError, or nil if none found.
func (m *ConversationUpdateTips) ValidateAll() error {
	return m.validate(true)
}

func (m *ConversationUpdateTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if len(errors) > 0 {
		return ConversationUpdateTipsMultiError(errors)
	}

	return nil
}

// ConversationUpdateTipsMultiError is an error wrapping multiple validation
// errors returned by ConversationUpdateTips.ValidateAll() if the designated
// constraints aren't met.
type ConversationUpdateTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConversationUpdateTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConversationUpdateTipsMultiError) AllErrors() []error { return m }

// ConversationUpdateTipsValidationError is the validation error returned by
// ConversationUpdateTips.Validate if the designated constraints aren't met.
type ConversationUpdateTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConversationUpdateTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConversationUpdateTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConversationUpdateTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConversationUpdateTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConversationUpdateTipsValidationError) ErrorName() string {
	return "ConversationUpdateTipsValidationError"
}

// Error satisfies the builtin error interface
func (e ConversationUpdateTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConversationUpdateTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConversationUpdateTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConversationUpdateTipsValidationError{}

// Validate checks the field values on ConversationSetPrivateTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConversationSetPrivateTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConversationSetPrivateTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConversationSetPrivateTipsMultiError, or nil if none found.
func (m *ConversationSetPrivateTips) ValidateAll() error {
	return m.validate(true)
}

func (m *ConversationSetPrivateTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RecvID

	// no validation rules for SendID

	// no validation rules for IsPrivate

	// no validation rules for ConversationID

	if len(errors) > 0 {
		return ConversationSetPrivateTipsMultiError(errors)
	}

	return nil
}

// ConversationSetPrivateTipsMultiError is an error wrapping multiple
// validation errors returned by ConversationSetPrivateTips.ValidateAll() if
// the designated constraints aren't met.
type ConversationSetPrivateTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConversationSetPrivateTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConversationSetPrivateTipsMultiError) AllErrors() []error { return m }

// ConversationSetPrivateTipsValidationError is the validation error returned
// by ConversationSetPrivateTips.Validate if the designated constraints aren't met.
type ConversationSetPrivateTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConversationSetPrivateTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConversationSetPrivateTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConversationSetPrivateTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConversationSetPrivateTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConversationSetPrivateTipsValidationError) ErrorName() string {
	return "ConversationSetPrivateTipsValidationError"
}

// Error satisfies the builtin error interface
func (e ConversationSetPrivateTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConversationSetPrivateTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConversationSetPrivateTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConversationSetPrivateTipsValidationError{}

// Validate checks the field values on ConversationHasReadTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConversationHasReadTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConversationHasReadTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConversationHasReadTipsMultiError, or nil if none found.
func (m *ConversationHasReadTips) ValidateAll() error {
	return m.validate(true)
}

func (m *ConversationHasReadTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for ConversationID

	// no validation rules for HasReadSeq

	// no validation rules for UnreadCountTime

	if len(errors) > 0 {
		return ConversationHasReadTipsMultiError(errors)
	}

	return nil
}

// ConversationHasReadTipsMultiError is an error wrapping multiple validation
// errors returned by ConversationHasReadTips.ValidateAll() if the designated
// constraints aren't met.
type ConversationHasReadTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConversationHasReadTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConversationHasReadTipsMultiError) AllErrors() []error { return m }

// ConversationHasReadTipsValidationError is the validation error returned by
// ConversationHasReadTips.Validate if the designated constraints aren't met.
type ConversationHasReadTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConversationHasReadTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConversationHasReadTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConversationHasReadTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConversationHasReadTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConversationHasReadTipsValidationError) ErrorName() string {
	return "ConversationHasReadTipsValidationError"
}

// Error satisfies the builtin error interface
func (e ConversationHasReadTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConversationHasReadTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConversationHasReadTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConversationHasReadTipsValidationError{}

// Validate checks the field values on NotificationElem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NotificationElem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotificationElem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NotificationElemMultiError, or nil if none found.
func (m *NotificationElem) ValidateAll() error {
	return m.validate(true)
}

func (m *NotificationElem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Detail

	if len(errors) > 0 {
		return NotificationElemMultiError(errors)
	}

	return nil
}

// NotificationElemMultiError is an error wrapping multiple validation errors
// returned by NotificationElem.ValidateAll() if the designated constraints
// aren't met.
type NotificationElemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotificationElemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotificationElemMultiError) AllErrors() []error { return m }

// NotificationElemValidationError is the validation error returned by
// NotificationElem.Validate if the designated constraints aren't met.
type NotificationElemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotificationElemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotificationElemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotificationElemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotificationElemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotificationElemValidationError) ErrorName() string { return "NotificationElemValidationError" }

// Error satisfies the builtin error interface
func (e NotificationElemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotificationElem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotificationElemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotificationElemValidationError{}

// Validate checks the field values on Seqs with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Seqs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Seqs with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SeqsMultiError, or nil if none found.
func (m *Seqs) ValidateAll() error {
	return m.validate(true)
}

func (m *Seqs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SeqsMultiError(errors)
	}

	return nil
}

// SeqsMultiError is an error wrapping multiple validation errors returned by
// Seqs.ValidateAll() if the designated constraints aren't met.
type SeqsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SeqsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SeqsMultiError) AllErrors() []error { return m }

// SeqsValidationError is the validation error returned by Seqs.Validate if the
// designated constraints aren't met.
type SeqsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SeqsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SeqsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SeqsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SeqsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SeqsValidationError) ErrorName() string { return "SeqsValidationError" }

// Error satisfies the builtin error interface
func (e SeqsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSeqs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SeqsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SeqsValidationError{}

// Validate checks the field values on DeleteMessageTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteMessageTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMessageTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMessageTipsMultiError, or nil if none found.
func (m *DeleteMessageTips) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMessageTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OpUserID

	// no validation rules for UserID

	if len(errors) > 0 {
		return DeleteMessageTipsMultiError(errors)
	}

	return nil
}

// DeleteMessageTipsMultiError is an error wrapping multiple validation errors
// returned by DeleteMessageTips.ValidateAll() if the designated constraints
// aren't met.
type DeleteMessageTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMessageTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMessageTipsMultiError) AllErrors() []error { return m }

// DeleteMessageTipsValidationError is the validation error returned by
// DeleteMessageTips.Validate if the designated constraints aren't met.
type DeleteMessageTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMessageTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMessageTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMessageTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMessageTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMessageTipsValidationError) ErrorName() string {
	return "DeleteMessageTipsValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMessageTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMessageTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMessageTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMessageTipsValidationError{}

// Validate checks the field values on RevokeMsgTips with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RevokeMsgTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeMsgTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RevokeMsgTipsMultiError, or
// nil if none found.
func (m *RevokeMsgTips) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeMsgTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RevokerUserID

	// no validation rules for ClientMsgID

	// no validation rules for RevokeTime

	// no validation rules for SesstionType

	// no validation rules for Seq

	// no validation rules for ConversationID

	// no validation rules for IsAdminRevoke

	if len(errors) > 0 {
		return RevokeMsgTipsMultiError(errors)
	}

	return nil
}

// RevokeMsgTipsMultiError is an error wrapping multiple validation errors
// returned by RevokeMsgTips.ValidateAll() if the designated constraints
// aren't met.
type RevokeMsgTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeMsgTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeMsgTipsMultiError) AllErrors() []error { return m }

// RevokeMsgTipsValidationError is the validation error returned by
// RevokeMsgTips.Validate if the designated constraints aren't met.
type RevokeMsgTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeMsgTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeMsgTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeMsgTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeMsgTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeMsgTipsValidationError) ErrorName() string { return "RevokeMsgTipsValidationError" }

// Error satisfies the builtin error interface
func (e RevokeMsgTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeMsgTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeMsgTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeMsgTipsValidationError{}

// Validate checks the field values on MessageRevokedContent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MessageRevokedContent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MessageRevokedContent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MessageRevokedContentMultiError, or nil if none found.
func (m *MessageRevokedContent) ValidateAll() error {
	return m.validate(true)
}

func (m *MessageRevokedContent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RevokerID

	// no validation rules for RevokerRole

	// no validation rules for ClientMsgID

	// no validation rules for RevokerNickname

	// no validation rules for RevokeTime

	// no validation rules for SourceMessageSendTime

	// no validation rules for SourceMessageSendID

	// no validation rules for SourceMessageSenderNickname

	// no validation rules for SessionType

	// no validation rules for Seq

	// no validation rules for Ex

	if len(errors) > 0 {
		return MessageRevokedContentMultiError(errors)
	}

	return nil
}

// MessageRevokedContentMultiError is an error wrapping multiple validation
// errors returned by MessageRevokedContent.ValidateAll() if the designated
// constraints aren't met.
type MessageRevokedContentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessageRevokedContentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessageRevokedContentMultiError) AllErrors() []error { return m }

// MessageRevokedContentValidationError is the validation error returned by
// MessageRevokedContent.Validate if the designated constraints aren't met.
type MessageRevokedContentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessageRevokedContentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessageRevokedContentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessageRevokedContentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessageRevokedContentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessageRevokedContentValidationError) ErrorName() string {
	return "MessageRevokedContentValidationError"
}

// Error satisfies the builtin error interface
func (e MessageRevokedContentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessageRevokedContent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessageRevokedContentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessageRevokedContentValidationError{}

// Validate checks the field values on ClearConversationTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClearConversationTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClearConversationTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClearConversationTipsMultiError, or nil if none found.
func (m *ClearConversationTips) ValidateAll() error {
	return m.validate(true)
}

func (m *ClearConversationTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if len(errors) > 0 {
		return ClearConversationTipsMultiError(errors)
	}

	return nil
}

// ClearConversationTipsMultiError is an error wrapping multiple validation
// errors returned by ClearConversationTips.ValidateAll() if the designated
// constraints aren't met.
type ClearConversationTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClearConversationTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClearConversationTipsMultiError) AllErrors() []error { return m }

// ClearConversationTipsValidationError is the validation error returned by
// ClearConversationTips.Validate if the designated constraints aren't met.
type ClearConversationTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClearConversationTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClearConversationTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClearConversationTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClearConversationTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClearConversationTipsValidationError) ErrorName() string {
	return "ClearConversationTipsValidationError"
}

// Error satisfies the builtin error interface
func (e ClearConversationTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClearConversationTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClearConversationTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClearConversationTipsValidationError{}

// Validate checks the field values on DeleteMsgsTips with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteMsgsTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMsgsTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteMsgsTipsMultiError,
// or nil if none found.
func (m *DeleteMsgsTips) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMsgsTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for ConversationID

	if len(errors) > 0 {
		return DeleteMsgsTipsMultiError(errors)
	}

	return nil
}

// DeleteMsgsTipsMultiError is an error wrapping multiple validation errors
// returned by DeleteMsgsTips.ValidateAll() if the designated constraints
// aren't met.
type DeleteMsgsTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMsgsTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMsgsTipsMultiError) AllErrors() []error { return m }

// DeleteMsgsTipsValidationError is the validation error returned by
// DeleteMsgsTips.Validate if the designated constraints aren't met.
type DeleteMsgsTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMsgsTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMsgsTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMsgsTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMsgsTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMsgsTipsValidationError) ErrorName() string { return "DeleteMsgsTipsValidationError" }

// Error satisfies the builtin error interface
func (e DeleteMsgsTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMsgsTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMsgsTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMsgsTipsValidationError{}

// Validate checks the field values on MarkAsReadTips with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MarkAsReadTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkAsReadTips with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MarkAsReadTipsMultiError,
// or nil if none found.
func (m *MarkAsReadTips) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkAsReadTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MarkAsReadUserID

	// no validation rules for ConversationID

	// no validation rules for HasReadSeq

	if len(errors) > 0 {
		return MarkAsReadTipsMultiError(errors)
	}

	return nil
}

// MarkAsReadTipsMultiError is an error wrapping multiple validation errors
// returned by MarkAsReadTips.ValidateAll() if the designated constraints
// aren't met.
type MarkAsReadTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkAsReadTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkAsReadTipsMultiError) AllErrors() []error { return m }

// MarkAsReadTipsValidationError is the validation error returned by
// MarkAsReadTips.Validate if the designated constraints aren't met.
type MarkAsReadTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkAsReadTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkAsReadTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkAsReadTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkAsReadTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkAsReadTipsValidationError) ErrorName() string { return "MarkAsReadTipsValidationError" }

// Error satisfies the builtin error interface
func (e MarkAsReadTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkAsReadTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkAsReadTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkAsReadTipsValidationError{}

// Validate checks the field values on SetAppBackgroundStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetAppBackgroundStatusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetAppBackgroundStatusReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetAppBackgroundStatusReqMultiError, or nil if none found.
func (m *SetAppBackgroundStatusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetAppBackgroundStatusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for IsBackground

	if len(errors) > 0 {
		return SetAppBackgroundStatusReqMultiError(errors)
	}

	return nil
}

// SetAppBackgroundStatusReqMultiError is an error wrapping multiple validation
// errors returned by SetAppBackgroundStatusReq.ValidateAll() if the
// designated constraints aren't met.
type SetAppBackgroundStatusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetAppBackgroundStatusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetAppBackgroundStatusReqMultiError) AllErrors() []error { return m }

// SetAppBackgroundStatusReqValidationError is the validation error returned by
// SetAppBackgroundStatusReq.Validate if the designated constraints aren't met.
type SetAppBackgroundStatusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetAppBackgroundStatusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetAppBackgroundStatusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetAppBackgroundStatusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetAppBackgroundStatusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetAppBackgroundStatusReqValidationError) ErrorName() string {
	return "SetAppBackgroundStatusReqValidationError"
}

// Error satisfies the builtin error interface
func (e SetAppBackgroundStatusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetAppBackgroundStatusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetAppBackgroundStatusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetAppBackgroundStatusReqValidationError{}

// Validate checks the field values on SetAppBackgroundStatusResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetAppBackgroundStatusResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetAppBackgroundStatusResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetAppBackgroundStatusRespMultiError, or nil if none found.
func (m *SetAppBackgroundStatusResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SetAppBackgroundStatusResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetAppBackgroundStatusRespMultiError(errors)
	}

	return nil
}

// SetAppBackgroundStatusRespMultiError is an error wrapping multiple
// validation errors returned by SetAppBackgroundStatusResp.ValidateAll() if
// the designated constraints aren't met.
type SetAppBackgroundStatusRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetAppBackgroundStatusRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetAppBackgroundStatusRespMultiError) AllErrors() []error { return m }

// SetAppBackgroundStatusRespValidationError is the validation error returned
// by SetAppBackgroundStatusResp.Validate if the designated constraints aren't met.
type SetAppBackgroundStatusRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetAppBackgroundStatusRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetAppBackgroundStatusRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetAppBackgroundStatusRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetAppBackgroundStatusRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetAppBackgroundStatusRespValidationError) ErrorName() string {
	return "SetAppBackgroundStatusRespValidationError"
}

// Error satisfies the builtin error interface
func (e SetAppBackgroundStatusRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetAppBackgroundStatusResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetAppBackgroundStatusRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetAppBackgroundStatusRespValidationError{}

// Validate checks the field values on ProcessUserCommand with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessUserCommand) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessUserCommand with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessUserCommandMultiError, or nil if none found.
func (m *ProcessUserCommand) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessUserCommand) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for Type

	// no validation rules for CreateTime

	// no validation rules for Uuid

	// no validation rules for Value

	if len(errors) > 0 {
		return ProcessUserCommandMultiError(errors)
	}

	return nil
}

// ProcessUserCommandMultiError is an error wrapping multiple validation errors
// returned by ProcessUserCommand.ValidateAll() if the designated constraints
// aren't met.
type ProcessUserCommandMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessUserCommandMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessUserCommandMultiError) AllErrors() []error { return m }

// ProcessUserCommandValidationError is the validation error returned by
// ProcessUserCommand.Validate if the designated constraints aren't met.
type ProcessUserCommandValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessUserCommandValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessUserCommandValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessUserCommandValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessUserCommandValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessUserCommandValidationError) ErrorName() string {
	return "ProcessUserCommandValidationError"
}

// Error satisfies the builtin error interface
func (e ProcessUserCommandValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessUserCommand.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessUserCommandValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessUserCommandValidationError{}

// Validate checks the field values on RequestPagination with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RequestPagination) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestPagination with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestPaginationMultiError, or nil if none found.
func (m *RequestPagination) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestPagination) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNumber

	// no validation rules for ShowNumber

	if len(errors) > 0 {
		return RequestPaginationMultiError(errors)
	}

	return nil
}

// RequestPaginationMultiError is an error wrapping multiple validation errors
// returned by RequestPagination.ValidateAll() if the designated constraints
// aren't met.
type RequestPaginationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestPaginationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestPaginationMultiError) AllErrors() []error { return m }

// RequestPaginationValidationError is the validation error returned by
// RequestPagination.Validate if the designated constraints aren't met.
type RequestPaginationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestPaginationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestPaginationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestPaginationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestPaginationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestPaginationValidationError) ErrorName() string {
	return "RequestPaginationValidationError"
}

// Error satisfies the builtin error interface
func (e RequestPaginationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestPagination.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestPaginationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestPaginationValidationError{}

// Validate checks the field values on FriendsInfoUpdateTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FriendsInfoUpdateTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FriendsInfoUpdateTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FriendsInfoUpdateTipsMultiError, or nil if none found.
func (m *FriendsInfoUpdateTips) ValidateAll() error {
	return m.validate(true)
}

func (m *FriendsInfoUpdateTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFromToUserID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FriendsInfoUpdateTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FriendsInfoUpdateTipsValidationError{
					field:  "FromToUserID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFromToUserID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FriendsInfoUpdateTipsValidationError{
				field:  "FromToUserID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FriendVersion

	// no validation rules for FriendVersionID

	if len(errors) > 0 {
		return FriendsInfoUpdateTipsMultiError(errors)
	}

	return nil
}

// FriendsInfoUpdateTipsMultiError is an error wrapping multiple validation
// errors returned by FriendsInfoUpdateTips.ValidateAll() if the designated
// constraints aren't met.
type FriendsInfoUpdateTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FriendsInfoUpdateTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FriendsInfoUpdateTipsMultiError) AllErrors() []error { return m }

// FriendsInfoUpdateTipsValidationError is the validation error returned by
// FriendsInfoUpdateTips.Validate if the designated constraints aren't met.
type FriendsInfoUpdateTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FriendsInfoUpdateTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FriendsInfoUpdateTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FriendsInfoUpdateTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FriendsInfoUpdateTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FriendsInfoUpdateTipsValidationError) ErrorName() string {
	return "FriendsInfoUpdateTipsValidationError"
}

// Error satisfies the builtin error interface
func (e FriendsInfoUpdateTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFriendsInfoUpdateTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FriendsInfoUpdateTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FriendsInfoUpdateTipsValidationError{}

// Validate checks the field values on SubUserOnlineStatusElem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubUserOnlineStatusElem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubUserOnlineStatusElem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubUserOnlineStatusElemMultiError, or nil if none found.
func (m *SubUserOnlineStatusElem) ValidateAll() error {
	return m.validate(true)
}

func (m *SubUserOnlineStatusElem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if len(errors) > 0 {
		return SubUserOnlineStatusElemMultiError(errors)
	}

	return nil
}

// SubUserOnlineStatusElemMultiError is an error wrapping multiple validation
// errors returned by SubUserOnlineStatusElem.ValidateAll() if the designated
// constraints aren't met.
type SubUserOnlineStatusElemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubUserOnlineStatusElemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubUserOnlineStatusElemMultiError) AllErrors() []error { return m }

// SubUserOnlineStatusElemValidationError is the validation error returned by
// SubUserOnlineStatusElem.Validate if the designated constraints aren't met.
type SubUserOnlineStatusElemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubUserOnlineStatusElemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubUserOnlineStatusElemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubUserOnlineStatusElemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubUserOnlineStatusElemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubUserOnlineStatusElemValidationError) ErrorName() string {
	return "SubUserOnlineStatusElemValidationError"
}

// Error satisfies the builtin error interface
func (e SubUserOnlineStatusElemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubUserOnlineStatusElem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubUserOnlineStatusElemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubUserOnlineStatusElemValidationError{}

// Validate checks the field values on SubUserOnlineStatusTips with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubUserOnlineStatusTips) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubUserOnlineStatusTips with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubUserOnlineStatusTipsMultiError, or nil if none found.
func (m *SubUserOnlineStatusTips) ValidateAll() error {
	return m.validate(true)
}

func (m *SubUserOnlineStatusTips) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSubscribers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubUserOnlineStatusTipsValidationError{
						field:  fmt.Sprintf("Subscribers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubUserOnlineStatusTipsValidationError{
						field:  fmt.Sprintf("Subscribers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubUserOnlineStatusTipsValidationError{
					field:  fmt.Sprintf("Subscribers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubUserOnlineStatusTipsMultiError(errors)
	}

	return nil
}

// SubUserOnlineStatusTipsMultiError is an error wrapping multiple validation
// errors returned by SubUserOnlineStatusTips.ValidateAll() if the designated
// constraints aren't met.
type SubUserOnlineStatusTipsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubUserOnlineStatusTipsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubUserOnlineStatusTipsMultiError) AllErrors() []error { return m }

// SubUserOnlineStatusTipsValidationError is the validation error returned by
// SubUserOnlineStatusTips.Validate if the designated constraints aren't met.
type SubUserOnlineStatusTipsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubUserOnlineStatusTipsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubUserOnlineStatusTipsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubUserOnlineStatusTipsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubUserOnlineStatusTipsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubUserOnlineStatusTipsValidationError) ErrorName() string {
	return "SubUserOnlineStatusTipsValidationError"
}

// Error satisfies the builtin error interface
func (e SubUserOnlineStatusTipsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubUserOnlineStatusTips.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubUserOnlineStatusTipsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubUserOnlineStatusTipsValidationError{}

// Validate checks the field values on SubUserOnlineStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubUserOnlineStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubUserOnlineStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubUserOnlineStatusMultiError, or nil if none found.
func (m *SubUserOnlineStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *SubUserOnlineStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SubUserOnlineStatusMultiError(errors)
	}

	return nil
}

// SubUserOnlineStatusMultiError is an error wrapping multiple validation
// errors returned by SubUserOnlineStatus.ValidateAll() if the designated
// constraints aren't met.
type SubUserOnlineStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubUserOnlineStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubUserOnlineStatusMultiError) AllErrors() []error { return m }

// SubUserOnlineStatusValidationError is the validation error returned by
// SubUserOnlineStatus.Validate if the designated constraints aren't met.
type SubUserOnlineStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubUserOnlineStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubUserOnlineStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubUserOnlineStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubUserOnlineStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubUserOnlineStatusValidationError) ErrorName() string {
	return "SubUserOnlineStatusValidationError"
}

// Error satisfies the builtin error interface
func (e SubUserOnlineStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubUserOnlineStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubUserOnlineStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubUserOnlineStatusValidationError{}
