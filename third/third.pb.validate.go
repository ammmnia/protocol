// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: third/third.proto

package third

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on KeyValues with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyValues) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyValues with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KeyValuesMultiError, or nil
// if none found.
func (m *KeyValues) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyValues) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return KeyValuesMultiError(errors)
	}

	return nil
}

// KeyValuesMultiError is an error wrapping multiple validation errors returned
// by KeyValues.ValidateAll() if the designated constraints aren't met.
type KeyValuesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyValuesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyValuesMultiError) AllErrors() []error { return m }

// KeyValuesValidationError is the validation error returned by
// KeyValues.Validate if the designated constraints aren't met.
type KeyValuesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyValuesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyValuesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyValuesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyValuesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyValuesValidationError) ErrorName() string { return "KeyValuesValidationError" }

// Error satisfies the builtin error interface
func (e KeyValuesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyValues.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyValuesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyValuesValidationError{}

// Validate checks the field values on SignPart with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignPart) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignPart with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignPartMultiError, or nil
// if none found.
func (m *SignPart) ValidateAll() error {
	return m.validate(true)
}

func (m *SignPart) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PartNumber

	// no validation rules for Url

	for idx, item := range m.GetQuery() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignPartValidationError{
						field:  fmt.Sprintf("Query[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignPartValidationError{
						field:  fmt.Sprintf("Query[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignPartValidationError{
					field:  fmt.Sprintf("Query[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetHeader() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignPartValidationError{
						field:  fmt.Sprintf("Header[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignPartValidationError{
						field:  fmt.Sprintf("Header[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignPartValidationError{
					field:  fmt.Sprintf("Header[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SignPartMultiError(errors)
	}

	return nil
}

// SignPartMultiError is an error wrapping multiple validation errors returned
// by SignPart.ValidateAll() if the designated constraints aren't met.
type SignPartMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignPartMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignPartMultiError) AllErrors() []error { return m }

// SignPartValidationError is the validation error returned by
// SignPart.Validate if the designated constraints aren't met.
type SignPartValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignPartValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignPartValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignPartValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignPartValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignPartValidationError) ErrorName() string { return "SignPartValidationError" }

// Error satisfies the builtin error interface
func (e SignPartValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignPart.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignPartValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignPartValidationError{}

// Validate checks the field values on AuthSignParts with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AuthSignParts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthSignParts with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthSignPartsMultiError, or
// nil if none found.
func (m *AuthSignParts) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthSignParts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	for idx, item := range m.GetQuery() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthSignPartsValidationError{
						field:  fmt.Sprintf("Query[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthSignPartsValidationError{
						field:  fmt.Sprintf("Query[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthSignPartsValidationError{
					field:  fmt.Sprintf("Query[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetHeader() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthSignPartsValidationError{
						field:  fmt.Sprintf("Header[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthSignPartsValidationError{
						field:  fmt.Sprintf("Header[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthSignPartsValidationError{
					field:  fmt.Sprintf("Header[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetParts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthSignPartsValidationError{
						field:  fmt.Sprintf("Parts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthSignPartsValidationError{
						field:  fmt.Sprintf("Parts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthSignPartsValidationError{
					field:  fmt.Sprintf("Parts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AuthSignPartsMultiError(errors)
	}

	return nil
}

// AuthSignPartsMultiError is an error wrapping multiple validation errors
// returned by AuthSignParts.ValidateAll() if the designated constraints
// aren't met.
type AuthSignPartsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthSignPartsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthSignPartsMultiError) AllErrors() []error { return m }

// AuthSignPartsValidationError is the validation error returned by
// AuthSignParts.Validate if the designated constraints aren't met.
type AuthSignPartsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthSignPartsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthSignPartsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthSignPartsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthSignPartsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthSignPartsValidationError) ErrorName() string { return "AuthSignPartsValidationError" }

// Error satisfies the builtin error interface
func (e AuthSignPartsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthSignParts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthSignPartsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthSignPartsValidationError{}

// Validate checks the field values on PartLimitReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PartLimitReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PartLimitReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PartLimitReqMultiError, or
// nil if none found.
func (m *PartLimitReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PartLimitReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PartLimitReqMultiError(errors)
	}

	return nil
}

// PartLimitReqMultiError is an error wrapping multiple validation errors
// returned by PartLimitReq.ValidateAll() if the designated constraints aren't met.
type PartLimitReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PartLimitReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PartLimitReqMultiError) AllErrors() []error { return m }

// PartLimitReqValidationError is the validation error returned by
// PartLimitReq.Validate if the designated constraints aren't met.
type PartLimitReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PartLimitReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PartLimitReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PartLimitReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PartLimitReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PartLimitReqValidationError) ErrorName() string { return "PartLimitReqValidationError" }

// Error satisfies the builtin error interface
func (e PartLimitReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPartLimitReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PartLimitReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PartLimitReqValidationError{}

// Validate checks the field values on PartLimitResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PartLimitResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PartLimitResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PartLimitRespMultiError, or
// nil if none found.
func (m *PartLimitResp) ValidateAll() error {
	return m.validate(true)
}

func (m *PartLimitResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MinPartSize

	// no validation rules for MaxPartSize

	// no validation rules for MaxNumSize

	if len(errors) > 0 {
		return PartLimitRespMultiError(errors)
	}

	return nil
}

// PartLimitRespMultiError is an error wrapping multiple validation errors
// returned by PartLimitResp.ValidateAll() if the designated constraints
// aren't met.
type PartLimitRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PartLimitRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PartLimitRespMultiError) AllErrors() []error { return m }

// PartLimitRespValidationError is the validation error returned by
// PartLimitResp.Validate if the designated constraints aren't met.
type PartLimitRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PartLimitRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PartLimitRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PartLimitRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PartLimitRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PartLimitRespValidationError) ErrorName() string { return "PartLimitRespValidationError" }

// Error satisfies the builtin error interface
func (e PartLimitRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPartLimitResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PartLimitRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PartLimitRespValidationError{}

// Validate checks the field values on PartSizeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PartSizeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PartSizeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PartSizeReqMultiError, or
// nil if none found.
func (m *PartSizeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PartSizeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Size

	if len(errors) > 0 {
		return PartSizeReqMultiError(errors)
	}

	return nil
}

// PartSizeReqMultiError is an error wrapping multiple validation errors
// returned by PartSizeReq.ValidateAll() if the designated constraints aren't met.
type PartSizeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PartSizeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PartSizeReqMultiError) AllErrors() []error { return m }

// PartSizeReqValidationError is the validation error returned by
// PartSizeReq.Validate if the designated constraints aren't met.
type PartSizeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PartSizeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PartSizeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PartSizeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PartSizeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PartSizeReqValidationError) ErrorName() string { return "PartSizeReqValidationError" }

// Error satisfies the builtin error interface
func (e PartSizeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPartSizeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PartSizeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PartSizeReqValidationError{}

// Validate checks the field values on PartSizeResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PartSizeResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PartSizeResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PartSizeRespMultiError, or
// nil if none found.
func (m *PartSizeResp) ValidateAll() error {
	return m.validate(true)
}

func (m *PartSizeResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Size

	if len(errors) > 0 {
		return PartSizeRespMultiError(errors)
	}

	return nil
}

// PartSizeRespMultiError is an error wrapping multiple validation errors
// returned by PartSizeResp.ValidateAll() if the designated constraints aren't met.
type PartSizeRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PartSizeRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PartSizeRespMultiError) AllErrors() []error { return m }

// PartSizeRespValidationError is the validation error returned by
// PartSizeResp.Validate if the designated constraints aren't met.
type PartSizeRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PartSizeRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PartSizeRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PartSizeRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PartSizeRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PartSizeRespValidationError) ErrorName() string { return "PartSizeRespValidationError" }

// Error satisfies the builtin error interface
func (e PartSizeRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPartSizeResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PartSizeRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PartSizeRespValidationError{}

// Validate checks the field values on InitiateMultipartUploadReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateMultipartUploadReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateMultipartUploadReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiateMultipartUploadReqMultiError, or nil if none found.
func (m *InitiateMultipartUploadReq) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateMultipartUploadReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	// no validation rules for Size

	// no validation rules for PartSize

	// no validation rules for MaxParts

	// no validation rules for Cause

	// no validation rules for Name

	// no validation rules for ContentType

	// no validation rules for UrlPrefix

	if len(errors) > 0 {
		return InitiateMultipartUploadReqMultiError(errors)
	}

	return nil
}

// InitiateMultipartUploadReqMultiError is an error wrapping multiple
// validation errors returned by InitiateMultipartUploadReq.ValidateAll() if
// the designated constraints aren't met.
type InitiateMultipartUploadReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateMultipartUploadReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateMultipartUploadReqMultiError) AllErrors() []error { return m }

// InitiateMultipartUploadReqValidationError is the validation error returned
// by InitiateMultipartUploadReq.Validate if the designated constraints aren't met.
type InitiateMultipartUploadReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateMultipartUploadReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateMultipartUploadReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateMultipartUploadReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateMultipartUploadReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateMultipartUploadReqValidationError) ErrorName() string {
	return "InitiateMultipartUploadReqValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateMultipartUploadReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateMultipartUploadReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateMultipartUploadReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateMultipartUploadReqValidationError{}

// Validate checks the field values on UploadInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UploadInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UploadInfoMultiError, or
// nil if none found.
func (m *UploadInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UploadID

	// no validation rules for PartSize

	if all {
		switch v := interface{}(m.GetSign()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UploadInfoValidationError{
					field:  "Sign",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UploadInfoValidationError{
					field:  "Sign",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSign()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UploadInfoValidationError{
				field:  "Sign",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExpireTime

	if len(errors) > 0 {
		return UploadInfoMultiError(errors)
	}

	return nil
}

// UploadInfoMultiError is an error wrapping multiple validation errors
// returned by UploadInfo.ValidateAll() if the designated constraints aren't met.
type UploadInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadInfoMultiError) AllErrors() []error { return m }

// UploadInfoValidationError is the validation error returned by
// UploadInfo.Validate if the designated constraints aren't met.
type UploadInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadInfoValidationError) ErrorName() string { return "UploadInfoValidationError" }

// Error satisfies the builtin error interface
func (e UploadInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadInfoValidationError{}

// Validate checks the field values on InitiateMultipartUploadResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateMultipartUploadResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateMultipartUploadResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiateMultipartUploadRespMultiError, or nil if none found.
func (m *InitiateMultipartUploadResp) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateMultipartUploadResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if all {
		switch v := interface{}(m.GetUpload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateMultipartUploadRespValidationError{
					field:  "Upload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateMultipartUploadRespValidationError{
					field:  "Upload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateMultipartUploadRespValidationError{
				field:  "Upload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InitiateMultipartUploadRespMultiError(errors)
	}

	return nil
}

// InitiateMultipartUploadRespMultiError is an error wrapping multiple
// validation errors returned by InitiateMultipartUploadResp.ValidateAll() if
// the designated constraints aren't met.
type InitiateMultipartUploadRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateMultipartUploadRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateMultipartUploadRespMultiError) AllErrors() []error { return m }

// InitiateMultipartUploadRespValidationError is the validation error returned
// by InitiateMultipartUploadResp.Validate if the designated constraints
// aren't met.
type InitiateMultipartUploadRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateMultipartUploadRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateMultipartUploadRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateMultipartUploadRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateMultipartUploadRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateMultipartUploadRespValidationError) ErrorName() string {
	return "InitiateMultipartUploadRespValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateMultipartUploadRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateMultipartUploadResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateMultipartUploadRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateMultipartUploadRespValidationError{}

// Validate checks the field values on AuthSignReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AuthSignReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthSignReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthSignReqMultiError, or
// nil if none found.
func (m *AuthSignReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthSignReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UploadID

	if len(errors) > 0 {
		return AuthSignReqMultiError(errors)
	}

	return nil
}

// AuthSignReqMultiError is an error wrapping multiple validation errors
// returned by AuthSignReq.ValidateAll() if the designated constraints aren't met.
type AuthSignReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthSignReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthSignReqMultiError) AllErrors() []error { return m }

// AuthSignReqValidationError is the validation error returned by
// AuthSignReq.Validate if the designated constraints aren't met.
type AuthSignReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthSignReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthSignReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthSignReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthSignReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthSignReqValidationError) ErrorName() string { return "AuthSignReqValidationError" }

// Error satisfies the builtin error interface
func (e AuthSignReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthSignReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthSignReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthSignReqValidationError{}

// Validate checks the field values on AuthSignResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AuthSignResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthSignResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthSignRespMultiError, or
// nil if none found.
func (m *AuthSignResp) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthSignResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	for idx, item := range m.GetQuery() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthSignRespValidationError{
						field:  fmt.Sprintf("Query[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthSignRespValidationError{
						field:  fmt.Sprintf("Query[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthSignRespValidationError{
					field:  fmt.Sprintf("Query[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetHeader() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthSignRespValidationError{
						field:  fmt.Sprintf("Header[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthSignRespValidationError{
						field:  fmt.Sprintf("Header[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthSignRespValidationError{
					field:  fmt.Sprintf("Header[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetParts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthSignRespValidationError{
						field:  fmt.Sprintf("Parts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthSignRespValidationError{
						field:  fmt.Sprintf("Parts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthSignRespValidationError{
					field:  fmt.Sprintf("Parts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AuthSignRespMultiError(errors)
	}

	return nil
}

// AuthSignRespMultiError is an error wrapping multiple validation errors
// returned by AuthSignResp.ValidateAll() if the designated constraints aren't met.
type AuthSignRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthSignRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthSignRespMultiError) AllErrors() []error { return m }

// AuthSignRespValidationError is the validation error returned by
// AuthSignResp.Validate if the designated constraints aren't met.
type AuthSignRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthSignRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthSignRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthSignRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthSignRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthSignRespValidationError) ErrorName() string { return "AuthSignRespValidationError" }

// Error satisfies the builtin error interface
func (e AuthSignRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthSignResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthSignRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthSignRespValidationError{}

// Validate checks the field values on CompleteMultipartUploadReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompleteMultipartUploadReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompleteMultipartUploadReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompleteMultipartUploadReqMultiError, or nil if none found.
func (m *CompleteMultipartUploadReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CompleteMultipartUploadReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UploadID

	// no validation rules for Name

	// no validation rules for ContentType

	// no validation rules for Cause

	// no validation rules for UrlPrefix

	if len(errors) > 0 {
		return CompleteMultipartUploadReqMultiError(errors)
	}

	return nil
}

// CompleteMultipartUploadReqMultiError is an error wrapping multiple
// validation errors returned by CompleteMultipartUploadReq.ValidateAll() if
// the designated constraints aren't met.
type CompleteMultipartUploadReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompleteMultipartUploadReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompleteMultipartUploadReqMultiError) AllErrors() []error { return m }

// CompleteMultipartUploadReqValidationError is the validation error returned
// by CompleteMultipartUploadReq.Validate if the designated constraints aren't met.
type CompleteMultipartUploadReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompleteMultipartUploadReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompleteMultipartUploadReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompleteMultipartUploadReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompleteMultipartUploadReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompleteMultipartUploadReqValidationError) ErrorName() string {
	return "CompleteMultipartUploadReqValidationError"
}

// Error satisfies the builtin error interface
func (e CompleteMultipartUploadReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompleteMultipartUploadReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompleteMultipartUploadReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompleteMultipartUploadReqValidationError{}

// Validate checks the field values on CompleteMultipartUploadResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompleteMultipartUploadResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompleteMultipartUploadResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompleteMultipartUploadRespMultiError, or nil if none found.
func (m *CompleteMultipartUploadResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CompleteMultipartUploadResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if len(errors) > 0 {
		return CompleteMultipartUploadRespMultiError(errors)
	}

	return nil
}

// CompleteMultipartUploadRespMultiError is an error wrapping multiple
// validation errors returned by CompleteMultipartUploadResp.ValidateAll() if
// the designated constraints aren't met.
type CompleteMultipartUploadRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompleteMultipartUploadRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompleteMultipartUploadRespMultiError) AllErrors() []error { return m }

// CompleteMultipartUploadRespValidationError is the validation error returned
// by CompleteMultipartUploadResp.Validate if the designated constraints
// aren't met.
type CompleteMultipartUploadRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompleteMultipartUploadRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompleteMultipartUploadRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompleteMultipartUploadRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompleteMultipartUploadRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompleteMultipartUploadRespValidationError) ErrorName() string {
	return "CompleteMultipartUploadRespValidationError"
}

// Error satisfies the builtin error interface
func (e CompleteMultipartUploadRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompleteMultipartUploadResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompleteMultipartUploadRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompleteMultipartUploadRespValidationError{}

// Validate checks the field values on AccessURLReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AccessURLReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccessURLReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AccessURLReqMultiError, or
// nil if none found.
func (m *AccessURLReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AccessURLReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Query

	if len(errors) > 0 {
		return AccessURLReqMultiError(errors)
	}

	return nil
}

// AccessURLReqMultiError is an error wrapping multiple validation errors
// returned by AccessURLReq.ValidateAll() if the designated constraints aren't met.
type AccessURLReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccessURLReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccessURLReqMultiError) AllErrors() []error { return m }

// AccessURLReqValidationError is the validation error returned by
// AccessURLReq.Validate if the designated constraints aren't met.
type AccessURLReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccessURLReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccessURLReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccessURLReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccessURLReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccessURLReqValidationError) ErrorName() string { return "AccessURLReqValidationError" }

// Error satisfies the builtin error interface
func (e AccessURLReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccessURLReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccessURLReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccessURLReqValidationError{}

// Validate checks the field values on AccessURLResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AccessURLResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccessURLResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AccessURLRespMultiError, or
// nil if none found.
func (m *AccessURLResp) ValidateAll() error {
	return m.validate(true)
}

func (m *AccessURLResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for ExpireTime

	if len(errors) > 0 {
		return AccessURLRespMultiError(errors)
	}

	return nil
}

// AccessURLRespMultiError is an error wrapping multiple validation errors
// returned by AccessURLResp.ValidateAll() if the designated constraints
// aren't met.
type AccessURLRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccessURLRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccessURLRespMultiError) AllErrors() []error { return m }

// AccessURLRespValidationError is the validation error returned by
// AccessURLResp.Validate if the designated constraints aren't met.
type AccessURLRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccessURLRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccessURLRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccessURLRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccessURLRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccessURLRespValidationError) ErrorName() string { return "AccessURLRespValidationError" }

// Error satisfies the builtin error interface
func (e AccessURLRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccessURLResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccessURLRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccessURLRespValidationError{}

// Validate checks the field values on InitiateFormDataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateFormDataReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateFormDataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiateFormDataReqMultiError, or nil if none found.
func (m *InitiateFormDataReq) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateFormDataReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Size

	// no validation rules for ContentType

	// no validation rules for Group

	// no validation rules for Millisecond

	// no validation rules for Absolute

	if len(errors) > 0 {
		return InitiateFormDataReqMultiError(errors)
	}

	return nil
}

// InitiateFormDataReqMultiError is an error wrapping multiple validation
// errors returned by InitiateFormDataReq.ValidateAll() if the designated
// constraints aren't met.
type InitiateFormDataReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateFormDataReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateFormDataReqMultiError) AllErrors() []error { return m }

// InitiateFormDataReqValidationError is the validation error returned by
// InitiateFormDataReq.Validate if the designated constraints aren't met.
type InitiateFormDataReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateFormDataReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateFormDataReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateFormDataReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateFormDataReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateFormDataReqValidationError) ErrorName() string {
	return "InitiateFormDataReqValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateFormDataReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateFormDataReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateFormDataReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateFormDataReqValidationError{}

// Validate checks the field values on InitiateFormDataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateFormDataResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateFormDataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiateFormDataRespMultiError, or nil if none found.
func (m *InitiateFormDataResp) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateFormDataResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Url

	// no validation rules for File

	for idx, item := range m.GetHeader() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InitiateFormDataRespValidationError{
						field:  fmt.Sprintf("Header[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InitiateFormDataRespValidationError{
						field:  fmt.Sprintf("Header[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InitiateFormDataRespValidationError{
					field:  fmt.Sprintf("Header[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for FormData

	// no validation rules for Expires

	if len(errors) > 0 {
		return InitiateFormDataRespMultiError(errors)
	}

	return nil
}

// InitiateFormDataRespMultiError is an error wrapping multiple validation
// errors returned by InitiateFormDataResp.ValidateAll() if the designated
// constraints aren't met.
type InitiateFormDataRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateFormDataRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateFormDataRespMultiError) AllErrors() []error { return m }

// InitiateFormDataRespValidationError is the validation error returned by
// InitiateFormDataResp.Validate if the designated constraints aren't met.
type InitiateFormDataRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateFormDataRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateFormDataRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateFormDataRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateFormDataRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateFormDataRespValidationError) ErrorName() string {
	return "InitiateFormDataRespValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateFormDataRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateFormDataResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateFormDataRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateFormDataRespValidationError{}

// Validate checks the field values on CompleteFormDataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompleteFormDataReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompleteFormDataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompleteFormDataReqMultiError, or nil if none found.
func (m *CompleteFormDataReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CompleteFormDataReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UrlPrefix

	if len(errors) > 0 {
		return CompleteFormDataReqMultiError(errors)
	}

	return nil
}

// CompleteFormDataReqMultiError is an error wrapping multiple validation
// errors returned by CompleteFormDataReq.ValidateAll() if the designated
// constraints aren't met.
type CompleteFormDataReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompleteFormDataReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompleteFormDataReqMultiError) AllErrors() []error { return m }

// CompleteFormDataReqValidationError is the validation error returned by
// CompleteFormDataReq.Validate if the designated constraints aren't met.
type CompleteFormDataReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompleteFormDataReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompleteFormDataReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompleteFormDataReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompleteFormDataReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompleteFormDataReqValidationError) ErrorName() string {
	return "CompleteFormDataReqValidationError"
}

// Error satisfies the builtin error interface
func (e CompleteFormDataReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompleteFormDataReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompleteFormDataReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompleteFormDataReqValidationError{}

// Validate checks the field values on CompleteFormDataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompleteFormDataResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompleteFormDataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompleteFormDataRespMultiError, or nil if none found.
func (m *CompleteFormDataResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CompleteFormDataResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if len(errors) > 0 {
		return CompleteFormDataRespMultiError(errors)
	}

	return nil
}

// CompleteFormDataRespMultiError is an error wrapping multiple validation
// errors returned by CompleteFormDataResp.ValidateAll() if the designated
// constraints aren't met.
type CompleteFormDataRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompleteFormDataRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompleteFormDataRespMultiError) AllErrors() []error { return m }

// CompleteFormDataRespValidationError is the validation error returned by
// CompleteFormDataResp.Validate if the designated constraints aren't met.
type CompleteFormDataRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompleteFormDataRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompleteFormDataRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompleteFormDataRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompleteFormDataRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompleteFormDataRespValidationError) ErrorName() string {
	return "CompleteFormDataRespValidationError"
}

// Error satisfies the builtin error interface
func (e CompleteFormDataRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompleteFormDataResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompleteFormDataRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompleteFormDataRespValidationError{}

// Validate checks the field values on DeleteOutdatedDataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteOutdatedDataReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteOutdatedDataReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteOutdatedDataReqMultiError, or nil if none found.
func (m *DeleteOutdatedDataReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteOutdatedDataReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExpireTime

	if len(errors) > 0 {
		return DeleteOutdatedDataReqMultiError(errors)
	}

	return nil
}

// DeleteOutdatedDataReqMultiError is an error wrapping multiple validation
// errors returned by DeleteOutdatedDataReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteOutdatedDataReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteOutdatedDataReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteOutdatedDataReqMultiError) AllErrors() []error { return m }

// DeleteOutdatedDataReqValidationError is the validation error returned by
// DeleteOutdatedDataReq.Validate if the designated constraints aren't met.
type DeleteOutdatedDataReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteOutdatedDataReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteOutdatedDataReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteOutdatedDataReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteOutdatedDataReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteOutdatedDataReqValidationError) ErrorName() string {
	return "DeleteOutdatedDataReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteOutdatedDataReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteOutdatedDataReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteOutdatedDataReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteOutdatedDataReqValidationError{}

// Validate checks the field values on DeleteOutdatedDataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteOutdatedDataResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteOutdatedDataResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteOutdatedDataRespMultiError, or nil if none found.
func (m *DeleteOutdatedDataResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteOutdatedDataResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteOutdatedDataRespMultiError(errors)
	}

	return nil
}

// DeleteOutdatedDataRespMultiError is an error wrapping multiple validation
// errors returned by DeleteOutdatedDataResp.ValidateAll() if the designated
// constraints aren't met.
type DeleteOutdatedDataRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteOutdatedDataRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteOutdatedDataRespMultiError) AllErrors() []error { return m }

// DeleteOutdatedDataRespValidationError is the validation error returned by
// DeleteOutdatedDataResp.Validate if the designated constraints aren't met.
type DeleteOutdatedDataRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteOutdatedDataRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteOutdatedDataRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteOutdatedDataRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteOutdatedDataRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteOutdatedDataRespValidationError) ErrorName() string {
	return "DeleteOutdatedDataRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteOutdatedDataRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteOutdatedDataResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteOutdatedDataRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteOutdatedDataRespValidationError{}

// Validate checks the field values on FcmUpdateTokenReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FcmUpdateTokenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FcmUpdateTokenReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FcmUpdateTokenReqMultiError, or nil if none found.
func (m *FcmUpdateTokenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *FcmUpdateTokenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlatformID

	// no validation rules for FcmToken

	// no validation rules for Account

	// no validation rules for ExpireTime

	if len(errors) > 0 {
		return FcmUpdateTokenReqMultiError(errors)
	}

	return nil
}

// FcmUpdateTokenReqMultiError is an error wrapping multiple validation errors
// returned by FcmUpdateTokenReq.ValidateAll() if the designated constraints
// aren't met.
type FcmUpdateTokenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FcmUpdateTokenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FcmUpdateTokenReqMultiError) AllErrors() []error { return m }

// FcmUpdateTokenReqValidationError is the validation error returned by
// FcmUpdateTokenReq.Validate if the designated constraints aren't met.
type FcmUpdateTokenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FcmUpdateTokenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FcmUpdateTokenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FcmUpdateTokenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FcmUpdateTokenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FcmUpdateTokenReqValidationError) ErrorName() string {
	return "FcmUpdateTokenReqValidationError"
}

// Error satisfies the builtin error interface
func (e FcmUpdateTokenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFcmUpdateTokenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FcmUpdateTokenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FcmUpdateTokenReqValidationError{}

// Validate checks the field values on FcmUpdateTokenResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FcmUpdateTokenResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FcmUpdateTokenResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FcmUpdateTokenRespMultiError, or nil if none found.
func (m *FcmUpdateTokenResp) ValidateAll() error {
	return m.validate(true)
}

func (m *FcmUpdateTokenResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FcmUpdateTokenRespMultiError(errors)
	}

	return nil
}

// FcmUpdateTokenRespMultiError is an error wrapping multiple validation errors
// returned by FcmUpdateTokenResp.ValidateAll() if the designated constraints
// aren't met.
type FcmUpdateTokenRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FcmUpdateTokenRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FcmUpdateTokenRespMultiError) AllErrors() []error { return m }

// FcmUpdateTokenRespValidationError is the validation error returned by
// FcmUpdateTokenResp.Validate if the designated constraints aren't met.
type FcmUpdateTokenRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FcmUpdateTokenRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FcmUpdateTokenRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FcmUpdateTokenRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FcmUpdateTokenRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FcmUpdateTokenRespValidationError) ErrorName() string {
	return "FcmUpdateTokenRespValidationError"
}

// Error satisfies the builtin error interface
func (e FcmUpdateTokenRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFcmUpdateTokenResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FcmUpdateTokenRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FcmUpdateTokenRespValidationError{}

// Validate checks the field values on SetAppBadgeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetAppBadgeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetAppBadgeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetAppBadgeReqMultiError,
// or nil if none found.
func (m *SetAppBadgeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetAppBadgeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for AppUnreadCount

	if len(errors) > 0 {
		return SetAppBadgeReqMultiError(errors)
	}

	return nil
}

// SetAppBadgeReqMultiError is an error wrapping multiple validation errors
// returned by SetAppBadgeReq.ValidateAll() if the designated constraints
// aren't met.
type SetAppBadgeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetAppBadgeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetAppBadgeReqMultiError) AllErrors() []error { return m }

// SetAppBadgeReqValidationError is the validation error returned by
// SetAppBadgeReq.Validate if the designated constraints aren't met.
type SetAppBadgeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetAppBadgeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetAppBadgeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetAppBadgeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetAppBadgeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetAppBadgeReqValidationError) ErrorName() string { return "SetAppBadgeReqValidationError" }

// Error satisfies the builtin error interface
func (e SetAppBadgeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetAppBadgeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetAppBadgeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetAppBadgeReqValidationError{}

// Validate checks the field values on SetAppBadgeResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SetAppBadgeResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetAppBadgeResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetAppBadgeRespMultiError, or nil if none found.
func (m *SetAppBadgeResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SetAppBadgeResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetAppBadgeRespMultiError(errors)
	}

	return nil
}

// SetAppBadgeRespMultiError is an error wrapping multiple validation errors
// returned by SetAppBadgeResp.ValidateAll() if the designated constraints
// aren't met.
type SetAppBadgeRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetAppBadgeRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetAppBadgeRespMultiError) AllErrors() []error { return m }

// SetAppBadgeRespValidationError is the validation error returned by
// SetAppBadgeResp.Validate if the designated constraints aren't met.
type SetAppBadgeRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetAppBadgeRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetAppBadgeRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetAppBadgeRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetAppBadgeRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetAppBadgeRespValidationError) ErrorName() string { return "SetAppBadgeRespValidationError" }

// Error satisfies the builtin error interface
func (e SetAppBadgeRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetAppBadgeResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetAppBadgeRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetAppBadgeRespValidationError{}

// Validate checks the field values on FileURL with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileURL) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileURL with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FileURLMultiError, or nil if none found.
func (m *FileURL) ValidateAll() error {
	return m.validate(true)
}

func (m *FileURL) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Filename

	// no validation rules for URL

	if len(errors) > 0 {
		return FileURLMultiError(errors)
	}

	return nil
}

// FileURLMultiError is an error wrapping multiple validation errors returned
// by FileURL.ValidateAll() if the designated constraints aren't met.
type FileURLMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileURLMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileURLMultiError) AllErrors() []error { return m }

// FileURLValidationError is the validation error returned by FileURL.Validate
// if the designated constraints aren't met.
type FileURLValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileURLValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileURLValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileURLValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileURLValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileURLValidationError) ErrorName() string { return "FileURLValidationError" }

// Error satisfies the builtin error interface
func (e FileURLValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileURL.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileURLValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileURLValidationError{}

// Validate checks the field values on UploadLogsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UploadLogsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadLogsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UploadLogsReqMultiError, or
// nil if none found.
func (m *UploadLogsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadLogsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Platform

	for idx, item := range m.GetFileURLs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UploadLogsReqValidationError{
						field:  fmt.Sprintf("FileURLs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UploadLogsReqValidationError{
						field:  fmt.Sprintf("FileURLs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UploadLogsReqValidationError{
					field:  fmt.Sprintf("FileURLs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for SystemType

	// no validation rules for Version

	// no validation rules for Ex

	if len(errors) > 0 {
		return UploadLogsReqMultiError(errors)
	}

	return nil
}

// UploadLogsReqMultiError is an error wrapping multiple validation errors
// returned by UploadLogsReq.ValidateAll() if the designated constraints
// aren't met.
type UploadLogsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadLogsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadLogsReqMultiError) AllErrors() []error { return m }

// UploadLogsReqValidationError is the validation error returned by
// UploadLogsReq.Validate if the designated constraints aren't met.
type UploadLogsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadLogsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadLogsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadLogsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadLogsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadLogsReqValidationError) ErrorName() string { return "UploadLogsReqValidationError" }

// Error satisfies the builtin error interface
func (e UploadLogsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadLogsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadLogsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadLogsReqValidationError{}

// Validate checks the field values on UploadLogsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UploadLogsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadLogsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UploadLogsRespMultiError,
// or nil if none found.
func (m *UploadLogsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadLogsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UploadLogsRespMultiError(errors)
	}

	return nil
}

// UploadLogsRespMultiError is an error wrapping multiple validation errors
// returned by UploadLogsResp.ValidateAll() if the designated constraints
// aren't met.
type UploadLogsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadLogsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadLogsRespMultiError) AllErrors() []error { return m }

// UploadLogsRespValidationError is the validation error returned by
// UploadLogsResp.Validate if the designated constraints aren't met.
type UploadLogsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadLogsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadLogsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadLogsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadLogsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadLogsRespValidationError) ErrorName() string { return "UploadLogsRespValidationError" }

// Error satisfies the builtin error interface
func (e UploadLogsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadLogsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadLogsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadLogsRespValidationError{}

// Validate checks the field values on DeleteLogsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteLogsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLogsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteLogsReqMultiError, or
// nil if none found.
func (m *DeleteLogsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLogsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteLogsReqMultiError(errors)
	}

	return nil
}

// DeleteLogsReqMultiError is an error wrapping multiple validation errors
// returned by DeleteLogsReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteLogsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLogsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLogsReqMultiError) AllErrors() []error { return m }

// DeleteLogsReqValidationError is the validation error returned by
// DeleteLogsReq.Validate if the designated constraints aren't met.
type DeleteLogsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLogsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLogsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLogsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLogsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLogsReqValidationError) ErrorName() string { return "DeleteLogsReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteLogsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLogsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLogsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLogsReqValidationError{}

// Validate checks the field values on DeleteLogsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteLogsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLogsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteLogsRespMultiError,
// or nil if none found.
func (m *DeleteLogsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLogsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteLogsRespMultiError(errors)
	}

	return nil
}

// DeleteLogsRespMultiError is an error wrapping multiple validation errors
// returned by DeleteLogsResp.ValidateAll() if the designated constraints
// aren't met.
type DeleteLogsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLogsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLogsRespMultiError) AllErrors() []error { return m }

// DeleteLogsRespValidationError is the validation error returned by
// DeleteLogsResp.Validate if the designated constraints aren't met.
type DeleteLogsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLogsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLogsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLogsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLogsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLogsRespValidationError) ErrorName() string { return "DeleteLogsRespValidationError" }

// Error satisfies the builtin error interface
func (e DeleteLogsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLogsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLogsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLogsRespValidationError{}

// Validate checks the field values on SearchLogsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SearchLogsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchLogsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SearchLogsReqMultiError, or
// nil if none found.
func (m *SearchLogsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchLogsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Keyword

	// no validation rules for StartTime

	// no validation rules for EndTime

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchLogsReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchLogsReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchLogsReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SearchLogsReqMultiError(errors)
	}

	return nil
}

// SearchLogsReqMultiError is an error wrapping multiple validation errors
// returned by SearchLogsReq.ValidateAll() if the designated constraints
// aren't met.
type SearchLogsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchLogsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchLogsReqMultiError) AllErrors() []error { return m }

// SearchLogsReqValidationError is the validation error returned by
// SearchLogsReq.Validate if the designated constraints aren't met.
type SearchLogsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchLogsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchLogsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchLogsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchLogsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchLogsReqValidationError) ErrorName() string { return "SearchLogsReqValidationError" }

// Error satisfies the builtin error interface
func (e SearchLogsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchLogsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchLogsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchLogsReqValidationError{}

// Validate checks the field values on LogInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LogInfoMultiError, or nil if none found.
func (m *LogInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *LogInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for Platform

	// no validation rules for Url

	// no validation rules for CreateTime

	// no validation rules for Nickname

	// no validation rules for LogID

	// no validation rules for Filename

	// no validation rules for SystemType

	// no validation rules for Ex

	// no validation rules for Version

	if len(errors) > 0 {
		return LogInfoMultiError(errors)
	}

	return nil
}

// LogInfoMultiError is an error wrapping multiple validation errors returned
// by LogInfo.ValidateAll() if the designated constraints aren't met.
type LogInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogInfoMultiError) AllErrors() []error { return m }

// LogInfoValidationError is the validation error returned by LogInfo.Validate
// if the designated constraints aren't met.
type LogInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogInfoValidationError) ErrorName() string { return "LogInfoValidationError" }

// Error satisfies the builtin error interface
func (e LogInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogInfoValidationError{}

// Validate checks the field values on SearchLogsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SearchLogsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchLogsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SearchLogsRespMultiError,
// or nil if none found.
func (m *SearchLogsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchLogsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLogsInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchLogsRespValidationError{
						field:  fmt.Sprintf("LogsInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchLogsRespValidationError{
						field:  fmt.Sprintf("LogsInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchLogsRespValidationError{
					field:  fmt.Sprintf("LogsInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return SearchLogsRespMultiError(errors)
	}

	return nil
}

// SearchLogsRespMultiError is an error wrapping multiple validation errors
// returned by SearchLogsResp.ValidateAll() if the designated constraints
// aren't met.
type SearchLogsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchLogsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchLogsRespMultiError) AllErrors() []error { return m }

// SearchLogsRespValidationError is the validation error returned by
// SearchLogsResp.Validate if the designated constraints aren't met.
type SearchLogsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchLogsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchLogsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchLogsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchLogsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchLogsRespValidationError) ErrorName() string { return "SearchLogsRespValidationError" }

// Error satisfies the builtin error interface
func (e SearchLogsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchLogsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchLogsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchLogsRespValidationError{}

// Validate checks the field values on ApplicationVersion with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationVersion with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationVersionMultiError, or nil if none found.
func (m *ApplicationVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Platform

	// no validation rules for Version

	// no validation rules for Url

	// no validation rules for Text

	// no validation rules for Force

	// no validation rules for Latest

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return ApplicationVersionMultiError(errors)
	}

	return nil
}

// ApplicationVersionMultiError is an error wrapping multiple validation errors
// returned by ApplicationVersion.ValidateAll() if the designated constraints
// aren't met.
type ApplicationVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationVersionMultiError) AllErrors() []error { return m }

// ApplicationVersionValidationError is the validation error returned by
// ApplicationVersion.Validate if the designated constraints aren't met.
type ApplicationVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationVersionValidationError) ErrorName() string {
	return "ApplicationVersionValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationVersionValidationError{}

// Validate checks the field values on LatestApplicationVersionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LatestApplicationVersionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LatestApplicationVersionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LatestApplicationVersionReqMultiError, or nil if none found.
func (m *LatestApplicationVersionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LatestApplicationVersionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Platform

	// no validation rules for Version

	if len(errors) > 0 {
		return LatestApplicationVersionReqMultiError(errors)
	}

	return nil
}

// LatestApplicationVersionReqMultiError is an error wrapping multiple
// validation errors returned by LatestApplicationVersionReq.ValidateAll() if
// the designated constraints aren't met.
type LatestApplicationVersionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LatestApplicationVersionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LatestApplicationVersionReqMultiError) AllErrors() []error { return m }

// LatestApplicationVersionReqValidationError is the validation error returned
// by LatestApplicationVersionReq.Validate if the designated constraints
// aren't met.
type LatestApplicationVersionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LatestApplicationVersionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LatestApplicationVersionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LatestApplicationVersionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LatestApplicationVersionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LatestApplicationVersionReqValidationError) ErrorName() string {
	return "LatestApplicationVersionReqValidationError"
}

// Error satisfies the builtin error interface
func (e LatestApplicationVersionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLatestApplicationVersionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LatestApplicationVersionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LatestApplicationVersionReqValidationError{}

// Validate checks the field values on LatestApplicationVersionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LatestApplicationVersionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LatestApplicationVersionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LatestApplicationVersionRespMultiError, or nil if none found.
func (m *LatestApplicationVersionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *LatestApplicationVersionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVersion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LatestApplicationVersionRespValidationError{
					field:  "Version",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LatestApplicationVersionRespValidationError{
					field:  "Version",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVersion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LatestApplicationVersionRespValidationError{
				field:  "Version",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LatestApplicationVersionRespMultiError(errors)
	}

	return nil
}

// LatestApplicationVersionRespMultiError is an error wrapping multiple
// validation errors returned by LatestApplicationVersionResp.ValidateAll() if
// the designated constraints aren't met.
type LatestApplicationVersionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LatestApplicationVersionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LatestApplicationVersionRespMultiError) AllErrors() []error { return m }

// LatestApplicationVersionRespValidationError is the validation error returned
// by LatestApplicationVersionResp.Validate if the designated constraints
// aren't met.
type LatestApplicationVersionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LatestApplicationVersionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LatestApplicationVersionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LatestApplicationVersionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LatestApplicationVersionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LatestApplicationVersionRespValidationError) ErrorName() string {
	return "LatestApplicationVersionRespValidationError"
}

// Error satisfies the builtin error interface
func (e LatestApplicationVersionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLatestApplicationVersionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LatestApplicationVersionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LatestApplicationVersionRespValidationError{}

// Validate checks the field values on AddApplicationVersionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddApplicationVersionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddApplicationVersionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddApplicationVersionReqMultiError, or nil if none found.
func (m *AddApplicationVersionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddApplicationVersionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Platform

	// no validation rules for Version

	// no validation rules for Url

	// no validation rules for Text

	// no validation rules for Force

	// no validation rules for Latest

	if len(errors) > 0 {
		return AddApplicationVersionReqMultiError(errors)
	}

	return nil
}

// AddApplicationVersionReqMultiError is an error wrapping multiple validation
// errors returned by AddApplicationVersionReq.ValidateAll() if the designated
// constraints aren't met.
type AddApplicationVersionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddApplicationVersionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddApplicationVersionReqMultiError) AllErrors() []error { return m }

// AddApplicationVersionReqValidationError is the validation error returned by
// AddApplicationVersionReq.Validate if the designated constraints aren't met.
type AddApplicationVersionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddApplicationVersionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddApplicationVersionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddApplicationVersionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddApplicationVersionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddApplicationVersionReqValidationError) ErrorName() string {
	return "AddApplicationVersionReqValidationError"
}

// Error satisfies the builtin error interface
func (e AddApplicationVersionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddApplicationVersionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddApplicationVersionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddApplicationVersionReqValidationError{}

// Validate checks the field values on AddApplicationVersionResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddApplicationVersionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddApplicationVersionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddApplicationVersionRespMultiError, or nil if none found.
func (m *AddApplicationVersionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *AddApplicationVersionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AddApplicationVersionRespMultiError(errors)
	}

	return nil
}

// AddApplicationVersionRespMultiError is an error wrapping multiple validation
// errors returned by AddApplicationVersionResp.ValidateAll() if the
// designated constraints aren't met.
type AddApplicationVersionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddApplicationVersionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddApplicationVersionRespMultiError) AllErrors() []error { return m }

// AddApplicationVersionRespValidationError is the validation error returned by
// AddApplicationVersionResp.Validate if the designated constraints aren't met.
type AddApplicationVersionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddApplicationVersionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddApplicationVersionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddApplicationVersionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddApplicationVersionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddApplicationVersionRespValidationError) ErrorName() string {
	return "AddApplicationVersionRespValidationError"
}

// Error satisfies the builtin error interface
func (e AddApplicationVersionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddApplicationVersionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddApplicationVersionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddApplicationVersionRespValidationError{}

// Validate checks the field values on UpdateApplicationVersionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateApplicationVersionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateApplicationVersionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateApplicationVersionReqMultiError, or nil if none found.
func (m *UpdateApplicationVersionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateApplicationVersionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetPlatform()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Platform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Platform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlatform()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateApplicationVersionReqValidationError{
				field:  "Platform",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVersion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Version",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Version",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVersion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateApplicationVersionReqValidationError{
				field:  "Version",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUrl()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Url",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Url",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUrl()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateApplicationVersionReqValidationError{
				field:  "Url",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetText()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Text",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Text",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetText()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateApplicationVersionReqValidationError{
				field:  "Text",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetForce()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Force",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Force",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetForce()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateApplicationVersionReqValidationError{
				field:  "Force",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLatest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Latest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateApplicationVersionReqValidationError{
					field:  "Latest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLatest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateApplicationVersionReqValidationError{
				field:  "Latest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateApplicationVersionReqMultiError(errors)
	}

	return nil
}

// UpdateApplicationVersionReqMultiError is an error wrapping multiple
// validation errors returned by UpdateApplicationVersionReq.ValidateAll() if
// the designated constraints aren't met.
type UpdateApplicationVersionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateApplicationVersionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateApplicationVersionReqMultiError) AllErrors() []error { return m }

// UpdateApplicationVersionReqValidationError is the validation error returned
// by UpdateApplicationVersionReq.Validate if the designated constraints
// aren't met.
type UpdateApplicationVersionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateApplicationVersionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateApplicationVersionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateApplicationVersionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateApplicationVersionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateApplicationVersionReqValidationError) ErrorName() string {
	return "UpdateApplicationVersionReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateApplicationVersionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateApplicationVersionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateApplicationVersionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateApplicationVersionReqValidationError{}

// Validate checks the field values on UpdateApplicationVersionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateApplicationVersionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateApplicationVersionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateApplicationVersionRespMultiError, or nil if none found.
func (m *UpdateApplicationVersionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateApplicationVersionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateApplicationVersionRespMultiError(errors)
	}

	return nil
}

// UpdateApplicationVersionRespMultiError is an error wrapping multiple
// validation errors returned by UpdateApplicationVersionResp.ValidateAll() if
// the designated constraints aren't met.
type UpdateApplicationVersionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateApplicationVersionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateApplicationVersionRespMultiError) AllErrors() []error { return m }

// UpdateApplicationVersionRespValidationError is the validation error returned
// by UpdateApplicationVersionResp.Validate if the designated constraints
// aren't met.
type UpdateApplicationVersionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateApplicationVersionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateApplicationVersionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateApplicationVersionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateApplicationVersionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateApplicationVersionRespValidationError) ErrorName() string {
	return "UpdateApplicationVersionRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateApplicationVersionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateApplicationVersionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateApplicationVersionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateApplicationVersionRespValidationError{}

// Validate checks the field values on DeleteApplicationVersionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteApplicationVersionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteApplicationVersionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteApplicationVersionReqMultiError, or nil if none found.
func (m *DeleteApplicationVersionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteApplicationVersionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteApplicationVersionReqMultiError(errors)
	}

	return nil
}

// DeleteApplicationVersionReqMultiError is an error wrapping multiple
// validation errors returned by DeleteApplicationVersionReq.ValidateAll() if
// the designated constraints aren't met.
type DeleteApplicationVersionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteApplicationVersionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteApplicationVersionReqMultiError) AllErrors() []error { return m }

// DeleteApplicationVersionReqValidationError is the validation error returned
// by DeleteApplicationVersionReq.Validate if the designated constraints
// aren't met.
type DeleteApplicationVersionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteApplicationVersionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteApplicationVersionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteApplicationVersionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteApplicationVersionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteApplicationVersionReqValidationError) ErrorName() string {
	return "DeleteApplicationVersionReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteApplicationVersionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteApplicationVersionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteApplicationVersionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteApplicationVersionReqValidationError{}

// Validate checks the field values on DeleteApplicationVersionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteApplicationVersionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteApplicationVersionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteApplicationVersionRespMultiError, or nil if none found.
func (m *DeleteApplicationVersionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteApplicationVersionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteApplicationVersionRespMultiError(errors)
	}

	return nil
}

// DeleteApplicationVersionRespMultiError is an error wrapping multiple
// validation errors returned by DeleteApplicationVersionResp.ValidateAll() if
// the designated constraints aren't met.
type DeleteApplicationVersionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteApplicationVersionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteApplicationVersionRespMultiError) AllErrors() []error { return m }

// DeleteApplicationVersionRespValidationError is the validation error returned
// by DeleteApplicationVersionResp.Validate if the designated constraints
// aren't met.
type DeleteApplicationVersionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteApplicationVersionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteApplicationVersionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteApplicationVersionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteApplicationVersionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteApplicationVersionRespValidationError) ErrorName() string {
	return "DeleteApplicationVersionRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteApplicationVersionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteApplicationVersionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteApplicationVersionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteApplicationVersionRespValidationError{}

// Validate checks the field values on PageApplicationVersionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PageApplicationVersionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageApplicationVersionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageApplicationVersionReqMultiError, or nil if none found.
func (m *PageApplicationVersionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PageApplicationVersionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PageApplicationVersionReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PageApplicationVersionReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PageApplicationVersionReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PageApplicationVersionReqMultiError(errors)
	}

	return nil
}

// PageApplicationVersionReqMultiError is an error wrapping multiple validation
// errors returned by PageApplicationVersionReq.ValidateAll() if the
// designated constraints aren't met.
type PageApplicationVersionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageApplicationVersionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageApplicationVersionReqMultiError) AllErrors() []error { return m }

// PageApplicationVersionReqValidationError is the validation error returned by
// PageApplicationVersionReq.Validate if the designated constraints aren't met.
type PageApplicationVersionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageApplicationVersionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageApplicationVersionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageApplicationVersionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageApplicationVersionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageApplicationVersionReqValidationError) ErrorName() string {
	return "PageApplicationVersionReqValidationError"
}

// Error satisfies the builtin error interface
func (e PageApplicationVersionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageApplicationVersionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageApplicationVersionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageApplicationVersionReqValidationError{}

// Validate checks the field values on PageApplicationVersionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PageApplicationVersionResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageApplicationVersionResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PageApplicationVersionRespMultiError, or nil if none found.
func (m *PageApplicationVersionResp) ValidateAll() error {
	return m.validate(true)
}

func (m *PageApplicationVersionResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PageApplicationVersionRespValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PageApplicationVersionRespValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PageApplicationVersionRespValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PageApplicationVersionRespMultiError(errors)
	}

	return nil
}

// PageApplicationVersionRespMultiError is an error wrapping multiple
// validation errors returned by PageApplicationVersionResp.ValidateAll() if
// the designated constraints aren't met.
type PageApplicationVersionRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageApplicationVersionRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageApplicationVersionRespMultiError) AllErrors() []error { return m }

// PageApplicationVersionRespValidationError is the validation error returned
// by PageApplicationVersionResp.Validate if the designated constraints aren't met.
type PageApplicationVersionRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageApplicationVersionRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageApplicationVersionRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageApplicationVersionRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageApplicationVersionRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageApplicationVersionRespValidationError) ErrorName() string {
	return "PageApplicationVersionRespValidationError"
}

// Error satisfies the builtin error interface
func (e PageApplicationVersionRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageApplicationVersionResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageApplicationVersionRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageApplicationVersionRespValidationError{}
